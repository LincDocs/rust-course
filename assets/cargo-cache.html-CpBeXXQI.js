import{_ as c,e as o,f as a,o as i}from"./app-DFfX2bp8.js";const r={};function d(s,e){return i(),o("div",null,e[0]||(e[0]=[a(`<h1 id="cargo-缓存" tabindex="-1"><a class="header-anchor" href="#cargo-缓存"><span>Cargo 缓存</span></a></h1><p>Cargo 使用了缓存的方式提升构建效率，当构建时，Cargo 会将已下载的依赖包放在 <code>CARGO_HOME</code> 目录下，下面一起来看看。</p><h2 id="cargo-home" tabindex="-1"><a class="header-anchor" href="#cargo-home"><span>Cargo Home</span></a></h2><p>默认情况下，Cargo Home 所在的目录是 <code>$HOME/.cargo/</code>，例如在 <code>macos</code> ，对应的目录是:</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> echo</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> $HOME</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/.cargo/</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">/Users/sunfei/.cargo/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们也可以通过修改 <code>CARGO_HOME</code> 环境变量的方式来重新设定该目录的位置。若你需要在项目中通过代码的方式来获取 <code>CARGO_HOME</code> ，<a href="https://crates.io/crates/home" target="_blank" rel="noopener noreferrer"><code>home</code></a> 包提供了相应的 API。</p><blockquote><p>注意！ Cargo Home 目录的内部结构并没有稳定化，在未来可能会发生变化</p></blockquote><h2 id="文件" tabindex="-1"><a class="header-anchor" href="#文件"><span>文件</span></a></h2><ul><li><code>config.toml</code> 是 Cargo 的全局配置文件，具体请查看<a href="https://course.rs/cargo/reference/configuration.html" target="_blank" rel="noopener noreferrer">这里</a></li><li><code>credentials.toml</code> 为 <code>cargo login</code> 提供私有化登录证书，用于登录 <code>package</code> 注册中心，例如 <code>crates.io</code></li><li><code>.crates.toml</code>, <code>.crates2.json</code> 这两个是隐藏文件，包含了通过 <code>cargo install</code> 安装的包的 <code>package</code> 信息，<strong>请不要手动修改！</strong></li></ul><h2 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h2><ul><li><code>bin</code> 目录包含了通过 <code>cargo install</code> 或 <code>rustup</code> 下载的包编译出的可执行文件。你可以将该目录加入到 <code>$PATH</code> 环境变量中，以实现对这些可执行文件的直接访问</li><li><code>git</code> 中存储了 <code>Git</code> 的资源文件: <ul><li><code>git/db</code>，当一个包依赖某个 <code>git</code> 仓库时，<code>Cargo</code> 会将该仓库克隆到 <code>git/db</code> 目录下，如果未来需要还会对其进行更新</li><li><code>git/checkouts</code>，若指定了 <code>git</code> 源和 <code>commit</code>，那相应的仓库就会从 <code>git/db</code> 中 <code>checkout</code> 到该目录下，因此同一个仓库的不同 <code>checkout</code> 共存成为了可能性</li></ul></li><li><code>registry</code> 包含了注册中心( 例如 <code>crates.io</code> )的元数据 和 <code>packages</code><ul><li><code>registry/index</code> 是一个 git 仓库，包含了注册中心中所有可用包的元数据( 版本、依赖等 )</li><li><code>registry/cache</code> 中保存了已下载的依赖，这些依赖包以 <code>gzip</code> 的压缩档案形式保存，后缀名为 <code>.crate</code></li><li><code>registry/src</code>，若一个已下载的 <code>.crate</code> 档案被一个 <code>package</code> 所需要，该档案会被解压缩到 <code>registry/src</code> 文件夹下，最终 <code>rustc</code> 可以在其中找到所需的 <code>.rs</code> 文件</li></ul></li></ul><h2 id="在-ci-时缓存-cargo-home" tabindex="-1"><a class="header-anchor" href="#在-ci-时缓存-cargo-home"><span>在 CI 时缓存 Cargo Home</span></a></h2><p>为了避免持续集成时重复下载所有的包依赖，我们可以将 <code>$CARGO_HOME</code> 目录进行缓存，但缓存整个目录是效率低下的，原因是源文件可能会被缓存两次。</p><p>例如我们依赖一个包 <code>serde 1.0.92</code>，如果将整个 <code>$CACHE_HOME</code> 目录缓存，那么<code>serde</code> 的源文件就会被缓存两次：在 <code>registry/cache</code> 中的 <code>serde-1.0.92.crate</code> 以及 <code>registry/src</code> 下被解压缩的 <code>.rs</code> 文件。</p><p>因此，在 CI 构建时，出于效率的考虑，我们仅应该缓存以下目录:</p><ul><li><code>bin/</code></li><li><code>registry/index/</code></li><li><code>registry/cache/</code></li><li><code>git/db/</code></li></ul><h2 id="清除缓存" tabindex="-1"><a class="header-anchor" href="#清除缓存"><span>清除缓存</span></a></h2><p>理论上，我们可以手动移除缓存中的任何一部分，当后续有包需要时 <code>Cargo</code> 会尽可能去恢复这些资源：</p><ul><li>解压缩 <code>registry/cache</code> 下的 <code>.crate</code> 档案</li><li>从 <code>.git</code> 中 <code>checkout</code> 缓存的仓库</li><li>如果以上都没了，会从网络上重新下载</li></ul><p>你也可以使用 <a href="https://crates.io/crates/cargo-cache" target="_blank" rel="noopener noreferrer">cargo-cache</a> 包来选择性的清除 <code>cache</code> 中指定的部分，当然，它还可以用来查看缓存中的组件大小。</p><h2 id="构建时卡住-blocking-waiting-for-file-lock" tabindex="-1"><a class="header-anchor" href="#构建时卡住-blocking-waiting-for-file-lock"><span>构建时卡住：Blocking waiting for file lock ..</span></a></h2><p>在开发过程中，或多或少我们都会碰到这种问题，例如你同时打开了 VSCode IDE 和终端，然后在 <code>Cargo.toml</code> 中刚添加了一个新的依赖。</p><p>此时 IDE 会捕捉到这个修改然后自动去重新下载依赖(这个过程可能还会更新 <code>crates.io</code> 使用的索引列表)，在此过程中， Cargo 会将相关信息写入到 <code>$HOME/.cargo/.package_cache</code> 下，并将其锁住。</p><p>如果你试图在另一个地方(例如终端)对同一个项目进行构建，就会报错: <code>Blocking waiting for file lock on package cache</code>。</p><p>解决办法很简单：</p><ul><li>既然下载慢，那就使用<a href="https://course.rs/cargo/reference/specify-deps.html#%E4%BB%8E%E5%85%B6%E5%AE%83%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E5%8C%85" target="_blank" rel="noopener noreferrer">国内的注册服务</a>，不再使用 crates.io</li><li>耐心等待持有锁的用户构建完成</li><li>强行停止正在构建的进程，例如杀掉 IDE 使用的 rust-analyer 插件进程，然后删除 <code>$HOME/.cargo/.package_cache</code> 目录</li></ul>`,26)]))}const l=c(r,[["render",d],["__file","cargo-cache.html.vue"]]),n=JSON.parse('{"path":"/src/cargo/guide/cargo-cache.html","title":"Cargo 缓存","lang":"zh-CN","frontmatter":{"description":"Cargo 缓存 Cargo 使用了缓存的方式提升构建效率，当构建时，Cargo 会将已下载的依赖包放在 CARGO_HOME 目录下，下面一起来看看。 Cargo Home 默认情况下，Cargo Home 所在的目录是 $HOME/.cargo/，例如在 macos ，对应的目录是: 我们也可以通过修改 CARGO_HOME 环境变量的方式来重新设...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/src/cargo/guide/cargo-cache.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"Cargo 缓存"}],["meta",{"property":"og:description","content":"Cargo 缓存 Cargo 使用了缓存的方式提升构建效率，当构建时，Cargo 会将已下载的依赖包放在 CARGO_HOME 目录下，下面一起来看看。 Cargo Home 默认情况下，Cargo Home 所在的目录是 $HOME/.cargo/，例如在 macos ，对应的目录是: 我们也可以通过修改 CARGO_HOME 环境变量的方式来重新设..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-24T15:57:50.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-24T15:57:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Cargo 缓存\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-24T15:57:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{"createdTime":1745510270000,"updatedTime":1745510270000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":3.45,"words":1035},"filePathRelative":"src/cargo/guide/cargo-cache.md","localizedDate":"2025年4月24日","excerpt":"\\n<p>Cargo 使用了缓存的方式提升构建效率，当构建时，Cargo 会将已下载的依赖包放在 <code>CARGO_HOME</code> 目录下，下面一起来看看。</p>\\n<h2>Cargo Home</h2>\\n<p>默认情况下，Cargo Home 所在的目录是 <code>$HOME/.cargo/</code>，例如在 <code>macos</code> ，对应的目录是:</p>\\n<div class=\\"language-shell line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"shell\\" data-title=\\"shell\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">$</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\"> echo</span><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\"> $HOME</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\">/.cargo/</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">/Users/sunfei/.cargo/</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"src/SUMMARY.html"}],"localMap":{"nodes":[{"id":"src/cargo/guide/cargo-cache.md","value":{"title":"cargo-cache","path":"src/cargo/guide/cargo-cache.md","outlink":[],"backlink":["src/SUMMARY.md"]}},{"id":"src/SUMMARY.md","value":{"title":"SUMMARY","path":"src/SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"src/SUMMARY.md","target":"src/cargo/guide/cargo-cache.md"}]}}}');export{l as comp,n as data};
