import{_ as i,e as a,k as e,o as t}from"./app-Jcta1ofV.js";const n={};function l(p,s){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="工作空间-workspace" tabindex="-1"><a class="header-anchor" href="#工作空间-workspace"><span>工作空间 Workspace</span></a></h1><p>一个工作空间是由多个 <code>package</code> 组成的集合，它们共享同一个 <code>Cargo.lock</code> 文件、输出目录和一些设置(例如 profiles : 编译器设置和优化)。组成工作空间的 <code>packages</code> 被称之为工作空间的成员。</p><h2 id="工作空间的两种类型" tabindex="-1"><a class="header-anchor" href="#工作空间的两种类型"><span>工作空间的两种类型</span></a></h2><p>工作空间有两种类型：<code>root package</code> 和虚拟清单( virtual manifest )。</p><h4 id="根-package" tabindex="-1"><a class="header-anchor" href="#根-package"><span>根 package</span></a></h4><p><strong>若一个 <code>package</code> 的 <code>Cargo.toml</code> 包含了<code>[package]</code> 的同时又包含了 <code>[workspace]</code> 部分，则该 <code>package</code> 被称为工作空间的根 <code>package</code></strong>。</p><p>换而言之，一个工作空间的根( root )是该工作空间的 <code>Cargo.toml</code> 文件所在的目录。</p><p>举个例子，我们现在有多个 <code>package</code>，它们的目录是嵌套关系，然后我们在最外层的 <code>package</code>，也就是最外层目录中的 <code>Cargo.toml</code> 中定义一个 <code>[workspace]</code>，此时这个最外层的 <code>package</code> 就是工作空间的根。</p><p>再举个例子，大名鼎鼎的 <a href="https://github.com/BurntSushi/ripgrep/blob/master/Cargo.toml" target="_blank" rel="noopener noreferrer">ripgrep</a> 就在最外层的 <code>package</code> 中定义了 <code>[workspace]</code> :</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" data-title="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">workspace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">members</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;crates/globset&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;crates/grep&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;crates/cli&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;crates/matcher&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;crates/pcre2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;crates/printer&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;crates/regex&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;crates/searcher&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;crates/ignore&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么<a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener noreferrer">最外层的目录</a>就是 <code>ripgrep</code> 的工作空间的根。</p><h4 id="虚拟清单" tabindex="-1"><a class="header-anchor" href="#虚拟清单"><span>虚拟清单</span></a></h4><p>若一个 <code>Cargo.toml</code> 有 <code>[workspace]</code> 但是没有 <code>[package]</code> 部分，则它是虚拟清单类型的工作空间。</p><p><strong>对于没有主 <code>package</code> 的场景或你希望将所有的 <code>package</code> 组织在单独的目录中时，这种方式就非常适合。</strong></p><p>例如 <a href="https://github.com/rust-analyzer/rust-analyzer" target="_blank" rel="noopener noreferrer">rust-analyzer</a> 就是这样的项目，它的根目录中的 <code>Cargo.toml</code> 中并没有 <code>[package]</code>，说明该根目录不是一个 <code>package</code>，但是却有 <code>[workspace]</code> :</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" data-title="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">workspace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">members</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;xtask/&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lib/*&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;crates/*&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">exclude</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;crates/proc_macro_test/imp&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合 rust-analyzer 的目录布局可以看出，<strong>该工作空间的所有成员 <code>package</code> 都在单独的目录中，因此这种方式很适合虚拟清单的工作空间。</strong></p><h2 id="关键特性" tabindex="-1"><a class="header-anchor" href="#关键特性"><span>关键特性</span></a></h2><p>工作空间的几个关键点在于:</p><ul><li>所有的 <code>package</code> 共享同一个 <code>Cargo.lock</code> 文件，该文件位于工作空间的根目录中</li><li>所有的 <code>package</code> 共享同一个<a href="https://course.rs/cargo/guide/build-cache.html" target="_blank" rel="noopener noreferrer">输出目录</a>，该目录默认的名称是 <code>target</code> ，位于工作空间根目录下</li><li>只有工作空间根目录的 <code>Cargo.toml</code> 才能包含 <code>[patch]</code>, <code>[replace]</code> 和 <code>[profile.*]</code>，而成员的 <code>Cargo.toml</code> 中的相应部分将被自动忽略</li></ul><h2 id="workspace" tabindex="-1"><a class="header-anchor" href="#workspace"><span>[workspace]</span></a></h2><p><code>Cargo.toml</code> 中的 <code>[workspace]</code> 部分用于定义哪些 <code>packages</code> 属于工作空间的成员:</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" data-title="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">workspace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">members</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;member1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;path/to/member2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;crates/*&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">exclude</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;crates/foo&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;path/to/other&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若某个本地依赖包是通过 <a href="https://course.rs/cargo/reference/specify-deps.html#%E9%80%9A%E8%BF%87%E8%B7%AF%E5%BE%84%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0%E4%BE%9D%E8%B5%96%E5%8C%85" target="_blank" rel="noopener noreferrer"><code>path</code></a> 引入，且该包位于工作空间的目录中，则该包自动成为工作空间的成员。</p><p>剩余的成员需要通过 <code>workspace.members</code> 来指定，里面包含了各个成员所在的目录(成员目录中包含了 Cargo.toml )。</p><p><code>members</code> 还支持使用 <a href="https://docs.rs/glob/0.3.0/glob/struct.Pattern.html" target="_blank" rel="noopener noreferrer"><code>glob</code></a> 来匹配多个路径，例如上面的例子中使用 <code>crates/*</code> 匹配 <code>crates</code> 目录下的所有包。</p><p><code>exclude</code> 可以将指定的目录排除在工作空间之外，例如还是上面的例子，<code>crates/*</code> 在包含了 <code>crates</code> 目录下的所有包后，又通过 <code>exclude</code> 中 <code>crates/foo</code> 将 <code>crates</code> 下的 <code>foo</code> 目录排除在外。</p><p>你也可以将一个空的 <code>[workspace]</code> 直接联合 <code>[package]</code> 使用，例如：</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" data-title="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">package</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello&quot;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">version</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;0.1.0&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">workspace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时的工作空间的成员包含:</p><ul><li>根 <code>package</code> : &quot;hello&quot;</li><li>所有通过 <code>path</code> 引入的本地依赖(位于工作空间目录下)</li></ul><h2 id="选择工作空间" tabindex="-1"><a class="header-anchor" href="#选择工作空间"><span>选择工作空间</span></a></h2><p>选择工作空间有两种方式：<code>Cargo</code> 自动查找、手动指定 <code>package.workspace</code> 字段。</p><p>当位于工作空间的子目录中时，<code>Cargo</code> 会自动在该目录的父目录中寻找带有 <code>[workspace]</code> 定义的 <code>Cargo.toml</code>，然后再决定使用哪个工作空间。</p><p>我们还可以使用下面的方法来覆盖 <code>Cargo</code> 自动查找功能：将成员包中的 <code>package.workspace</code> 字段修改为工作区间根目录的位置，这样就能显式地让一个成员使用指定的工作空间。</p><p>当成员不在工作空间的子目录下时，这种手动选择工作空间的方法就非常适用。毕竟 <code>Cargo</code> 的自动搜索是沿着父目录往上查找，而成员并不在工作空间的子目录下，这意味着顺着成员的父目录往上找是无法找到该工作空间的 <code>Cargo.toml</code> 的，此时就只能手动指定了。</p><h2 id="选择-package" tabindex="-1"><a class="header-anchor" href="#选择-package"><span>选择 package</span></a></h2><p>在工作空间中，<code>package</code> 相关的 <code>Cargo</code> 命令(例如 <code>cargo build</code> )可以使用 <code>-p</code> 、 <code>--package</code> 或 <code>--workspace</code> 命令行参数来指定想要操作的 <code>package</code>。</p><p>若没有指定任何参数，则 <code>Cargo</code> 将使用当前工作目录的中的 <code>package</code> 。若工作目录是虚拟清单类型的工作空间，则该命令将作用在所有成员上(就好像是使用了 <code>--workspace</code> 命令行参数)。而 <code>default-members</code> 可以在命令行参数没有被提供时，手动指定操作的成员:</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" data-title="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">workspace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">members</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;path/to/member1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;path/to/member2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;path/to/member3/*&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">default-members</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;path/to/member2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;path/to/member3/foo&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一来， <code>cargo build</code> 就不会应用到虚拟清单工作空间的所有成员，而是指定的成员上。</p><h2 id="workspace-metadata" tabindex="-1"><a class="header-anchor" href="#workspace-metadata"><span>workspace.metadata</span></a></h2><p>与 <a href="https://course.rs/cargo/reference/manifest.html#metadata" target="_blank" rel="noopener noreferrer">package.metadata</a> 非常类似，<code>workspace.metadata</code> 会被 <code>Cargo</code> 自动忽略，就算没有被使用也不会发出警告。</p><p>这个部分可以用于让工具在 <code>Cargo.toml</code> 中存储一些工作空间的配置元信息。例如:</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" data-title="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">workspace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">members</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;member1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;member2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">workspace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">metadata</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">webcontents</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;path/to/webproject&quot;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">tool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;npm&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;run&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;build&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,45)]))}const r=i(n,[["render",l],["__file","workspaces.html.vue"]]),h=JSON.parse('{"path":"/cargo/reference/workspaces.html","title":"工作空间 Workspace","lang":"zh-CN","frontmatter":{"description":"工作空间 Workspace 一个工作空间是由多个 package 组成的集合，它们共享同一个 Cargo.lock 文件、输出目录和一些设置(例如 profiles : 编译器设置和优化)。组成工作空间的 packages 被称之为工作空间的成员。 工作空间的两种类型 工作空间有两种类型：root package 和虚拟清单( virtual man...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/cargo/reference/workspaces.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"工作空间 Workspace"}],["meta",{"property":"og:description","content":"工作空间 Workspace 一个工作空间是由多个 package 组成的集合，它们共享同一个 Cargo.lock 文件、输出目录和一些设置(例如 profiles : 编译器设置和优化)。组成工作空间的 packages 被称之为工作空间的成员。 工作空间的两种类型 工作空间有两种类型：root package 和虚拟清单( virtual man..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"工作空间 Workspace\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{},"readingTime":{"minutes":4.49,"words":1346},"filePathRelative":"cargo/reference/workspaces.md","excerpt":"\\n<p>一个工作空间是由多个 <code>package</code> 组成的集合，它们共享同一个 <code>Cargo.lock</code> 文件、输出目录和一些设置(例如 profiles : 编译器设置和优化)。组成工作空间的 <code>packages</code> 被称之为工作空间的成员。</p>\\n<h2>工作空间的两种类型</h2>\\n<p>工作空间有两种类型：<code>root package</code> 和虚拟清单( virtual manifest )。</p>\\n<h4>根 package</h4>\\n<p><strong>若一个 <code>package</code> 的 <code>Cargo.toml</code> 包含了<code>[package]</code> 的同时又包含了 <code>[workspace]</code> 部分，则该 <code>package</code> 被称为工作空间的根 <code>package</code></strong>。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"cargo/reference/workspaces.md","value":{"title":"workspaces","path":"cargo/reference/workspaces.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"cargo/reference/workspaces.md"}]}}}');export{r as comp,h as data};
