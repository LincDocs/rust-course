import{_ as e,e as o,f as c,o as r}from"./app-C_xW6TWK.js";const i={};function n(s,t){return r(),o("div",null,t[0]||(t[0]=[c('<h1 id="集合类型" tabindex="-1"><a class="header-anchor" href="#集合类型"><span>集合类型</span></a></h1><p>在 Rust 标准库中有这样一批原住民，它们天生贵族，当你看到的一瞬间，就能爱上它们，上面是我瞎编的，其实主要是离了它们不行，不信等会我介绍后，你放个狠话，偏不用它们试试？</p><p>集合在 Rust 中是一类比较特殊的类型，因为 Rust 中大多数数据类型都只能代表一个特定的值，但是集合却可以代表一大堆值。而且与语言级别的数组、字符串类型不同，标准库里的这些家伙是分配在堆上，因此都可以进行动态的增加和减少。</p><p>瞧，第一个集合排着整齐的队列登场了，它里面的每个元素都雄赳赳气昂昂跟在另外一个元素后面，大小、宽度、高度竟然全部一致，真是令人惊叹。 它就是 <code>Vector</code> 类型，允许你创建一个动态数组，它里面的元素是一个紧挨着另一个排列的。</p><p>紧接着，第二个集合在全场的嘘声和羡慕眼光中闪亮登场，只见里面的元素排成一对一对的，彼此都手牵着手，非对方莫属，这种情深深雨蒙蒙的样子真是...挺欠扁的。 它就是 <code>HashMap</code> 类型，该类型允许你在里面存储 <code>KV</code> 对，每一个 <code>K</code> 都有唯一的 <code>V</code> 与之配对。</p><p>最后，请用热烈的掌声迎接我们的 <code>String</code> 集合，哦，抱歉，<code>String</code> 集合天生低调，见不得前两个那样，因此被气走了，你可以去<a href="https://course.rs/basic/compound-type/string-slice.html" target="_blank" rel="noopener noreferrer">这里</a>找它。</p><p>言归正传，本章所讲的 <code>Vector</code>、<code>HashMap</code> 再加上之前的 <code>String</code> 类型，是标准库中最最常用的集合类型，可以说，几乎任何一段代码中都可以找到它们的身影，那么先来看看 <code>Vector</code>。</p>',7)]))}const p=e(i,[["render",n],["__file","intro.html.vue"]]),d=JSON.parse('{"path":"/src/basic/collections/intro.html","title":"集合类型","lang":"zh-CN","frontmatter":{"description":"集合类型 在 Rust 标准库中有这样一批原住民，它们天生贵族，当你看到的一瞬间，就能爱上它们，上面是我瞎编的，其实主要是离了它们不行，不信等会我介绍后，你放个狠话，偏不用它们试试？ 集合在 Rust 中是一类比较特殊的类型，因为 Rust 中大多数数据类型都只能代表一个特定的值，但是集合却可以代表一大堆值。而且与语言级别的数组、字符串类型不同，标准库...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/src/basic/collections/intro.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"集合类型"}],["meta",{"property":"og:description","content":"集合类型 在 Rust 标准库中有这样一批原住民，它们天生贵族，当你看到的一瞬间，就能爱上它们，上面是我瞎编的，其实主要是离了它们不行，不信等会我介绍后，你放个狠话，偏不用它们试试？ 集合在 Rust 中是一类比较特殊的类型，因为 Rust 中大多数数据类型都只能代表一个特定的值，但是集合却可以代表一大堆值。而且与语言级别的数组、字符串类型不同，标准库..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-20T14:07:43.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-20T14:07:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"集合类型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-20T14:07:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{"createdTime":1745158063000,"updatedTime":1745158063000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":1.61,"words":484},"filePathRelative":"src/basic/collections/intro.md","localizedDate":"2025年4月20日","excerpt":"\\n<p>在 Rust 标准库中有这样一批原住民，它们天生贵族，当你看到的一瞬间，就能爱上它们，上面是我瞎编的，其实主要是离了它们不行，不信等会我介绍后，你放个狠话，偏不用它们试试？</p>\\n<p>集合在 Rust 中是一类比较特殊的类型，因为 Rust 中大多数数据类型都只能代表一个特定的值，但是集合却可以代表一大堆值。而且与语言级别的数组、字符串类型不同，标准库里的这些家伙是分配在堆上，因此都可以进行动态的增加和减少。</p>\\n<p>瞧，第一个集合排着整齐的队列登场了，它里面的每个元素都雄赳赳气昂昂跟在另外一个元素后面，大小、宽度、高度竟然全部一致，真是令人惊叹。 它就是 <code>Vector</code> 类型，允许你创建一个动态数组，它里面的元素是一个紧挨着另一个排列的。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"src/SUMMARY.html"}],"localMap":{"nodes":[{"id":"src/basic/collections/intro.md","value":{"title":"intro","path":"src/basic/collections/intro.md","outlink":[],"backlink":["src/SUMMARY.md"]}},{"id":"src/SUMMARY.md","value":{"title":"SUMMARY","path":"src/SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"src/SUMMARY.md","target":"src/basic/collections/intro.md"}]}}}');export{p as comp,d as data};
