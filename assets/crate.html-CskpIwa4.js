import{_ as s,e as a,f as i,o as n}from"./app-C_xW6TWK.js";const c={};function l(r,e){return n(),a("div",null,e[0]||(e[0]=[i(`<h1 id="包和-package" tabindex="-1"><a class="header-anchor" href="#包和-package"><span>包和 Package</span></a></h1><p>当读者按照章节顺序读到本章时，意味着你已经几乎具备了参与真实项目开发的能力。但是真实项目远比我们之前的 <code>cargo new</code> 的默认目录结构要复杂，好在，Rust 为我们提供了强大的包管理工具：</p><ul><li><strong>项目(Package)</strong>：可以用来构建、测试和分享包</li><li><strong>工作空间(WorkSpace)</strong>：对于大型项目，可以进一步将多个包联合在一起，组织成工作空间</li><li><strong>包(Crate)</strong>：一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行</li><li><strong>模块(Module)</strong>：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元</li></ul><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h2><p>其实项目 <code>Package</code> 和包 <code>Crate</code> 很容易被搞混，甚至在很多书中，这两者都是不分的，但是由于官方对此做了明确的区分，因此我们会在本章节中试图（挣扎着）理清这个概念。</p><h4 id="包-crate" tabindex="-1"><a class="header-anchor" href="#包-crate"><span>包 Crate</span></a></h4><p>对于 Rust 而言，包是一个独立的可编译单元，它编译后会生成一个可执行文件或者一个库。</p><p>一个包会将相关联的功能打包在一起，使得该功能可以很方便的在多个项目中分享。例如标准库中没有提供但是在三方库中提供的 <code>rand</code> 包，它提供了随机数生成的功能，我们只需要将该包通过 <code>use rand;</code> 引入到当前项目的作用域中，就可以在项目中使用 <code>rand</code> 的功能：<code>rand::XXX</code>。</p><p>同一个包中不能有同名的类型，但是在不同包中就可以。例如，虽然 <code>rand</code> 包中，有一个 <code>Rng</code> 特征，可是我们依然可以在自己的项目中定义一个 <code>Rng</code>，前者通过 <code>rand::Rng</code> 访问，后者通过 <code>Rng</code> 访问，对于编译器而言，这两者的边界非常清晰，不会存在引用歧义。</p><h2 id="项目-package" tabindex="-1"><a class="header-anchor" href="#项目-package"><span>项目 Package</span></a></h2><p>鉴于 Rust 团队标新立异的起名传统，以及包的名称被 <code>crate</code> 占用，库的名称被 <code>library</code> 占用，经过斟酌， 我们决定将 <code>Package</code> 翻译成项目，你也可以理解为工程、软件包。</p><p>由于 <code>Package</code> 就是一个项目，因此它包含有独立的 <code>Cargo.toml</code> 文件，以及因为功能性被组织在一起的一个或多个包。一个 <code>Package</code> 只能包含<strong>一个</strong>库(library)类型的包，但是可以包含<strong>多个</strong>二进制可执行类型的包。</p><h4 id="二进制-package" tabindex="-1"><a class="header-anchor" href="#二进制-package"><span>二进制 Package</span></a></h4><p>让我们来创建一个二进制 <code>Package</code>：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ cargo new my-project</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">     Created binary (application) \`my-project\` package</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ ls my-project</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Cargo.toml</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">src</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ ls my-project/src</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">main.rs</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，Cargo 为我们创建了一个名称是 <code>my-project</code> 的 <code>Package</code>，同时在其中创建了 <code>Cargo.toml</code> 文件，可以看一下该文件，里面并没有提到 <code>src/main.rs</code> 作为程序的入口，原因是 Cargo 有一个惯例：<strong><code>src/main.rs</code> 是二进制包的根文件，该二进制包的包名跟所属 <code>Package</code> 相同，在这里都是 <code>my-project</code></strong>，所有的代码执行都从该文件中的 <code>fn main()</code> 函数开始。</p><p>使用 <code>cargo run</code> 可以运行该项目，输出：<code>Hello, world!</code>。</p><h4 id="库-package" tabindex="-1"><a class="header-anchor" href="#库-package"><span>库 Package</span></a></h4><p>再来创建一个库类型的 <code>Package</code>：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ cargo new my-lib --lib</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">     Created library \`my-lib\` package</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ ls my-lib</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Cargo.toml</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">src</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ ls my-lib/src</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lib.rs</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，如果你试图运行 <code>my-lib</code>，会报错：</p><div class="language-console line-numbers-mode" data-highlighter="shiki" data-ext="console" data-title="console" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ cargo run</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">error: a bin target must be available for \`cargo run\`</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>原因是库类型的 <code>Package</code> 只能作为三方库被其它项目引用，而不能独立运行，只有之前的二进制 <code>Package</code> 才可以运行。</p><p>与 <code>src/main.rs</code> 一样，Cargo 知道，如果一个 <code>Package</code> 包含有 <code>src/lib.rs</code>，意味它包含有一个库类型的同名包 <code>my-lib</code>，该包的根文件是 <code>src/lib.rs</code>。</p><h4 id="易混淆的-package-和包" tabindex="-1"><a class="header-anchor" href="#易混淆的-package-和包"><span>易混淆的 Package 和包</span></a></h4><p>看完上面，相信大家看出来为何 <code>Package</code> 和包容易被混淆了吧？因为你用 <code>cargo new</code> 创建的 <code>Package</code> 和它其中包含的包是同名的！</p><p>不过，只要你牢记 <code>Package</code> 是一个项目工程，而包只是一个编译单元，也就不会再混淆这两个概念：<code>src/main.rs</code> 和 <code>src/lib.rs</code> 都是编译单元，因此它们都是包。</p><h4 id="典型的-package-结构" tabindex="-1"><a class="header-anchor" href="#典型的-package-结构"><span>典型的 <code>Package</code> 结构</span></a></h4><p>上面创建的 <code>Package</code> 中仅包含 <code>src/main.rs</code> 文件，意味着它仅包含一个二进制同名包 <code>my-project</code>。如果一个 <code>Package</code> 同时拥有 <code>src/main.rs</code> 和 <code>src/lib.rs</code>，那就意味着它包含两个包：库包和二进制包，这两个包名也都是 <code>my-project</code> —— 都与 <code>Package</code> 同名。</p><p>一个真实项目中典型的 <code>Package</code>，会包含多个二进制包，这些包文件被放在 <code>src/bin</code> 目录下，每一个文件都是独立的二进制包，同时也会包含一个库包，该包只能存在一个 <code>src/lib.rs</code>：</p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">├── Cargo</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.toml</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">├── Cargo</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.lock</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">├── src</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">│   ├── </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">main</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.rs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">│   ├── lib</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.rs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">│   └── bin</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">│       └── main1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.rs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">│       └── main2</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.rs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">├── tests</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">│   └── some_integration_tests</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.rs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">├── benches</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">│   └── simple_bench</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.rs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">└── examples</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    └── simple_example</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.rs</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>唯一库包：<code>src/lib.rs</code></li><li>默认二进制包：<code>src/main.rs</code>，编译后生成的可执行文件与 <code>Package</code> 同名</li><li>其余二进制包：<code>src/bin/main1.rs</code> 和 <code>src/bin/main2.rs</code>，它们会分别生成一个文件同名的二进制可执行文件</li><li>集成测试文件：<code>tests</code> 目录下</li><li>基准性能测试 <code>benchmark</code> 文件：<code>benches</code> 目录下</li><li>项目示例：<code>examples</code> 目录下</li></ul><p>这种目录结构基本上是 Rust 的标准目录结构，在 <code>GitHub</code> 的大多数项目上，你都将看到它的身影。</p><p>理解了包的概念，我们再来看看构成包的基本单元：模块。</p><h2 id="课后练习" tabindex="-1"><a class="header-anchor" href="#课后练习"><span>课后练习</span></a></h2><blockquote><p><a href="https://practice-zh.course.rs/crate-module/crate.html" target="_blank" rel="noopener noreferrer">Rust By Practice</a>，支持代码在线编辑和运行，并提供详细的<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/crate-module/crate.md" target="_blank" rel="noopener noreferrer">习题解答</a>。</p></blockquote>`,36)]))}const t=s(c,[["render",l],["__file","crate.html.vue"]]),o=JSON.parse('{"path":"/src/basic/crate-module/crate.html","title":"包和 Package","lang":"zh-CN","frontmatter":{"description":"包和 Package 当读者按照章节顺序读到本章时，意味着你已经几乎具备了参与真实项目开发的能力。但是真实项目远比我们之前的 cargo new 的默认目录结构要复杂，好在，Rust 为我们提供了强大的包管理工具： 项目(Package)：可以用来构建、测试和分享包 工作空间(WorkSpace)：对于大型项目，可以进一步将多个包联合在一起，组织成工作...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/src/basic/crate-module/crate.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"包和 Package"}],["meta",{"property":"og:description","content":"包和 Package 当读者按照章节顺序读到本章时，意味着你已经几乎具备了参与真实项目开发的能力。但是真实项目远比我们之前的 cargo new 的默认目录结构要复杂，好在，Rust 为我们提供了强大的包管理工具： 项目(Package)：可以用来构建、测试和分享包 工作空间(WorkSpace)：对于大型项目，可以进一步将多个包联合在一起，组织成工作..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-20T14:07:43.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-20T14:07:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"包和 Package\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-20T14:07:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{"createdTime":1745158063000,"updatedTime":1745158063000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":4.72,"words":1417},"filePathRelative":"src/basic/crate-module/crate.md","localizedDate":"2025年4月20日","excerpt":"\\n<p>当读者按照章节顺序读到本章时，意味着你已经几乎具备了参与真实项目开发的能力。但是真实项目远比我们之前的 <code>cargo new</code> 的默认目录结构要复杂，好在，Rust 为我们提供了强大的包管理工具：</p>\\n<ul>\\n<li><strong>项目(Package)</strong>：可以用来构建、测试和分享包</li>\\n<li><strong>工作空间(WorkSpace)</strong>：对于大型项目，可以进一步将多个包联合在一起，组织成工作空间</li>\\n<li><strong>包(Crate)</strong>：一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行</li>\\n<li><strong>模块(Module)</strong>：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"src/SUMMARY.html"}],"localMap":{"nodes":[{"id":"src/basic/crate-module/crate.md","value":{"title":"crate","path":"src/basic/crate-module/crate.md","outlink":[],"backlink":["src/SUMMARY.md"]}},{"id":"src/SUMMARY.md","value":{"title":"SUMMARY","path":"src/SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"src/SUMMARY.md","target":"src/basic/crate-module/crate.md"}]}}}');export{t as comp,o as data};
