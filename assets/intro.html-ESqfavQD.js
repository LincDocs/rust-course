import{_ as e,e as i,f as a,o as c}from"./app-BSEs7fAb.js";const o={};function n(r,t){return c(),i("div",null,t[0]||(t[0]=[a('<h1 id="实践应用-多线程web服务器" tabindex="-1"><a class="header-anchor" href="#实践应用-多线程web服务器"><span>实践应用：多线程Web服务器</span></a></h1><p>一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。</p><p>在本章中你将了解：</p><ol><li>学习一点 TCP 和 HTTP</li><li>在套接字 socket 上监听进入的 TCP 连接</li><li>解析 HTTP 请求</li><li>创建合适的 HTTP 应答</li><li>使用线程池来提升 web 服务器的吞吐量</li></ol><blockquote><p>本章的实现方法并不是在 Rust 中实现 Web 服务器的最佳方法，后续章节的 async/await 会更加适合!</p></blockquote>',5)]))}const s=e(o,[["render",n],["__file","intro.html.vue"]]),p=JSON.parse('{"path":"/src/advance-practice1/intro.html","title":"实践应用：多线程Web服务器","lang":"zh-CN","frontmatter":{"description":"实践应用：多线程Web服务器 一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。 在本章中你将了解： 学习一点 TCP 和 HTTP 在套接字 socket 上监听进入的 TCP...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/src/advance-practice1/intro.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"实践应用：多线程Web服务器"}],["meta",{"property":"og:description","content":"实践应用：多线程Web服务器 一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。 在本章中你将了解： 学习一点 TCP 和 HTTP 在套接字 socket 上监听进入的 TCP..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-20T14:07:43.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-20T14:07:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"实践应用：多线程Web服务器\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-20T14:07:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{"createdTime":1745158063000,"updatedTime":1745158063000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":0.66,"words":199},"filePathRelative":"src/advance-practice1/intro.md","localizedDate":"2025年4月20日","excerpt":"\\n<p>一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。</p>\\n<p>在本章中你将了解：</p>\\n<ol>\\n<li>学习一点 TCP 和 HTTP</li>\\n<li>在套接字 socket 上监听进入的 TCP 连接</li>\\n<li>解析 HTTP 请求</li>\\n<li>创建合适的 HTTP 应答</li>\\n<li>使用线程池来提升 web 服务器的吞吐量</li>\\n</ol>\\n<blockquote>\\n<p>本章的实现方法并不是在 Rust 中实现 Web 服务器的最佳方法，后续章节的 async/await 会更加适合!</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"src/SUMMARY.html"}],"localMap":{"nodes":[{"id":"src/advance-practice1/intro.md","value":{"title":"intro","path":"src/advance-practice1/intro.md","outlink":[],"backlink":["src/SUMMARY.md"]}},{"id":"src/SUMMARY.md","value":{"title":"SUMMARY","path":"src/SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"src/SUMMARY.md","target":"src/advance-practice1/intro.md"}]}}}');export{s as comp,p as data};
