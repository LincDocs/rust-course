import{_ as e,e as r,k as o,o as n}from"./app-D8oqi0-Y.js";const a={};function s(i,t){return n(),r("div",null,t[0]||(t[0]=[o('<h1 id="返回值和错误处理" tabindex="-1"><a class="header-anchor" href="#返回值和错误处理"><span>返回值和错误处理</span></a></h1><p>飞鸽传书、八百里加急，自古以来，掌权者最需要的就是及时获得对某个事物的信息反馈，在此过程中，也定义了相应的应急处理措施。</p><p>社会演变至今，这种思想依然没变，甚至来到计算中的微观世界，也是如此。及时、准确的获知系统在发生什么，是程序设计的重中之重。因此能够准确的分辨函数返回值是正确的还是错误的、以及在发生错误时该怎么快速处理，成了程序设计语言的必备功能。</p><p>Go 语言为人诟病的其中一点就是 <strong><em>if err != nil {}</em></strong> 的大量使用，缺乏一些程序设计的美感，不过我倒是觉得这种简单的方式也有其好处，就是阅读代码时的流畅感很强，你不需要过多的思考各种语法是什么意思。与 Go 语言不同，Rust 博采众家之长，实现了颇具自身色彩的返回值和错误处理体系，本章我们就高屋建瓴地来学习，更加深入的讲解见<a href="https://course.rs/advance/errors.html" target="_blank" rel="noopener noreferrer">错误处理</a>。</p><h2 id="rust-的错误哲学" tabindex="-1"><a class="header-anchor" href="#rust-的错误哲学"><span>Rust 的错误哲学</span></a></h2><p>错误对于软件来说是不可避免的，因此一门优秀的编程语言必须有其完整的错误处理哲学。在很多情况下，Rust 需要你承认自己的代码可能会出错，并提前采取行动，来处理这些错误。</p><p>Rust 中的错误主要分为两类：</p><ul><li><strong>可恢复错误</strong>，通常用于从系统全局角度来看可以接受的错误，例如处理用户的访问、操作等错误，这些错误只会影响某个用户自身的操作进程，而不会对系统的全局稳定性产生影响</li><li><strong>不可恢复错误</strong>，刚好相反，该错误通常是全局性或者系统性的错误，例如数组越界访问，系统启动时发生了影响启动流程的错误等等，这些错误的影响往往对于系统来说是致命的</li></ul><p>很多编程语言，并不会区分这些错误，而是直接采用异常的方式去处理。Rust 没有异常，但是 Rust 也有自己的卧龙凤雏：<code>Result&lt;T, E&gt;</code> 用于可恢复错误，<code>panic!</code> 用于不可恢复错误。</p>',9)]))}const c=e(a,[["render",s],["__file","intro.html.vue"]]),p=JSON.parse('{"path":"/basic/result-error/intro.html","title":"返回值和错误处理","lang":"zh-CN","frontmatter":{"description":"返回值和错误处理 飞鸽传书、八百里加急，自古以来，掌权者最需要的就是及时获得对某个事物的信息反馈，在此过程中，也定义了相应的应急处理措施。 社会演变至今，这种思想依然没变，甚至来到计算中的微观世界，也是如此。及时、准确的获知系统在发生什么，是程序设计的重中之重。因此能够准确的分辨函数返回值是正确的还是错误的、以及在发生错误时该怎么快速处理，成了程序设计...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/basic/result-error/intro.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"返回值和错误处理"}],["meta",{"property":"og:description","content":"返回值和错误处理 飞鸽传书、八百里加急，自古以来，掌权者最需要的就是及时获得对某个事物的信息反馈，在此过程中，也定义了相应的应急处理措施。 社会演变至今，这种思想依然没变，甚至来到计算中的微观世界，也是如此。及时、准确的获知系统在发生什么，是程序设计的重中之重。因此能够准确的分辨函数返回值是正确的还是错误的、以及在发生错误时该怎么快速处理，成了程序设计..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"返回值和错误处理\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{},"readingTime":{"minutes":2.05,"words":614},"filePathRelative":"basic/result-error/intro.md","excerpt":"\\n<p>飞鸽传书、八百里加急，自古以来，掌权者最需要的就是及时获得对某个事物的信息反馈，在此过程中，也定义了相应的应急处理措施。</p>\\n<p>社会演变至今，这种思想依然没变，甚至来到计算中的微观世界，也是如此。及时、准确的获知系统在发生什么，是程序设计的重中之重。因此能够准确的分辨函数返回值是正确的还是错误的、以及在发生错误时该怎么快速处理，成了程序设计语言的必备功能。</p>\\n<p>Go 语言为人诟病的其中一点就是 <strong><em>if err != nil {}</em></strong> 的大量使用，缺乏一些程序设计的美感，不过我倒是觉得这种简单的方式也有其好处，就是阅读代码时的流畅感很强，你不需要过多的思考各种语法是什么意思。与 Go 语言不同，Rust 博采众家之长，实现了颇具自身色彩的返回值和错误处理体系，本章我们就高屋建瓴地来学习，更加深入的讲解见<a href=\\"https://course.rs/advance/errors.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">错误处理</a>。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"basic/result-error/intro.md","value":{"title":"intro","path":"basic/result-error/intro.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"basic/result-error/intro.md"}]}}}');export{c as comp,p as data};
