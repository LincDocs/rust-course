import{_ as a,e as c,k as i,f as t,j as o,h as n,r as d,o as l}from"./app-DxZopsRG.js";const p={},r={href:"https://doc.rust-lang.org/std/collections/struct.LinkedList.html",target:"_blank",rel:"noopener noreferrer"};function h(u,e){const s=d("VPIcon");return l(),c("div",null,[e[3]||(e[3]=i(`<h2 id="我们到底需不需要链表" tabindex="-1"><a class="header-anchor" href="#我们到底需不需要链表"><span>我们到底需不需要链表</span></a></h2><p>经常有读者询问该如何实现一个链表，怎么说呢，这个答案主要取决于你的需求，因此并不是很好回答。鉴于此，我决定通过这本书来详尽的介绍该如何实现一个链表，大家应该都能从这本书中找到答案。</p><p>书中我们将通过实现 6 种链表来学习基本和进阶 Rust 编程知识，在此过程中，你能学到：</p><ul><li>指针类型: <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>*const</code>, <code>*mut</code>, <code>NonNull</code></li><li>所有权、借用、继承可变性、内部可变性、Copy</li><li>所有的关键字：struct、enum、fn、pub、impl、use, ...</li><li>模式匹配、泛型、解构</li><li>测试、安装新的工具链、使用 <code>miri</code></li><li>Unsafe: 裸指针、别名、栈借用、<code>UnsafeCell</code>、变体 variance</li></ul><p>是的，链表就是这么可怕，只有将这些知识融会贯通后，你才能掌握 😦</p><blockquote><p>事实上这本书中关于 Rust 语言的绝大部分知识都在 <code>Rust语言圣经</code>中有讲，因此除非特殊情况，我们将直接提供链接供大家学习，重点还是放在链表实现上</p></blockquote><h4 id="创建一个项目" tabindex="-1"><a class="header-anchor" href="#创建一个项目"><span>创建一个项目</span></a></h4><p>在开始前，先来创建一个项目专门用于链表学习：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cargo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> new</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --lib</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> lists</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> lists</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>之后，我们会将每个一个链表放入单独的文件中，需要注意的是我们会尽量模拟真实的 Rust 开发场景：你写了一段代码，然后编译器开始跳出试图教你做事，只有这样才能真正学会 Rust，温室环境是无法培养出强大的 Rustacean 的。</p><h4 id="义务告知" tabindex="-1"><a class="header-anchor" href="#义务告知"><span>义务告知</span></a></h4><p>首先，本书不是保姆式教程，而且我个人认为编程应该是快乐，这种快乐往往需要你自己发现而不是别人的事无巨细的讲解。</p><p>其次，我讨厌链表。链表真的是一种糟糕的数据结构，尽管它在部分场景下确实很有用：</p><ul><li>对列表进行大量的分割和合并操作</li><li>无锁并发</li><li>要实现内核或嵌入式的服务</li><li>你在使用一个纯函数式语言，由于受限的语法和缺少可变性，因此你需要使用链表来解决这些问题</li></ul><p>但是实事求是的说，这些场景对于几乎任何 Rust 开发都是很少遇到的，99% 的场景你可以使用 <code>Vec</code> 来替代，然后 1% 中的 99% 可以使用 <code>VecDeque</code>。 由于它们具有更少的内存分配次数、更低的内存占用、随机访问和缓存亲和特性，因此能够适用于绝大多数工作场景。总之，类似于 <code>trie</code> 树，链表也是一种非常小众的数据结构，特别是对于 Rust 开发而言。</p>`,15)),t("blockquote",null,[t("p",null,[e[2]||(e[2]=o("本书只是为了学习链表该如何实现，如果大家只是为了使用链表，强烈推荐直接使用标准库或者社区提供的现成实现，例如 ")),t("a",r,[e[0]||(e[0]=o("std")),n(s,{icon:"collections"}),e[1]||(e[1]=o("LinkedList"))])])]),e[4]||(e[4]=i('<h4 id="链表有-o-1-的分割、合并、插入、移除性能" tabindex="-1"><a class="header-anchor" href="#链表有-o-1-的分割、合并、插入、移除性能"><span>链表有 O(1) 的分割、合并、插入、移除性能</span></a></h4><p>是的，但是你首先要考虑的是，这些代码被调用的频率是怎么样的？是否在热点路径？ 答案如果是否定的，那么还是强烈建议使用 <code>Vec</code> 等传统数据结构，况且整个数组的拷贝也是相当快的！</p><p>况且，<code>Vec</code> 上的 <code>push</code> 和 <code>pop</code> 操作是 <code>O(1)</code> 的，它们比链表提供的 <code>push</code> 和 <code>pop</code> 要更快！我们只需要通过一个指针 + 内存偏移就可以访问了。</p><blockquote><p>关于是否使用链表这个问题，Bjarne Stroustrup 有过非常深入的<a href="https://www.youtube.com/watch?v=YQs6IC-vgmo" target="_blank" rel="noopener noreferrer">讲解</a></p></blockquote><p>但是如果你的整体项目确实因为某一段分割、合并的代码导致了性能低下，那么就放心大胆的使用链表吧。</p><h4 id="我无法接受内存重新分配的代价" tabindex="-1"><a class="header-anchor" href="#我无法接受内存重新分配的代价"><span>我无法接受内存重新分配的代价</span></a></h4><p>是的，<code>Vec</code> 当 <a href="https://practice-zh.course.rs/collections/vector.html#capacity" target="_blank" rel="noopener noreferrer"><code>capacity</code></a> 不够时，会重新分配一块内存，然后将之前的 <code>Vec</code> 全部拷贝过去，但是对于绝大多数使用场景，要么 <code>Vec</code> 不在热点路径中，要么 <code>Vec</code> 的容量可以提前预测。</p><p>对于前者，那性能如何自然无关紧要。而对于后者，我们只需要使用 <code>Vec::with_capacity</code> 提前分配足够的空间即可，同时，Rust 中所有的迭代器还提供了 <code>size_hint</code> 也可以解决这种问题。</p><p>当然，如果这段代码在热点路径，且你无法提前预测所需的容量，那么链表确实会更提升性能。</p><h4 id="链表更节省内存空间" tabindex="-1"><a class="header-anchor" href="#链表更节省内存空间"><span>链表更节省内存空间</span></a></h4><p>首先，这个问题较为复杂。一个标准的数组调整策略是：增加或减少数组的长度使数组最多有一半为空，例如 capacity 增长是翻倍的策略。这确实会导致内存空间的浪费，特别是在 Rust 中，我们不会自动收缩集合类型。</p><p>但是上面说的是最坏的情况，如果是最好的情况，那整个数组其实只有 3 个指针大小(指针在 Rust 中占用一个 word 的空间，例如 64 位机器就是 8 个字节的大小)的内存浪费，或者说，没有浪费。</p><p>而且链表实际上也有内存浪费，例如链表中的每个元素都会占用额外的内存：单向链表浪费一个指针，双向链表浪费两个指针。当然，如果你的链表中每个元素都很大，那相对来说，这种浪费也微不足道，但是如果链表的元素较小且数量很多呢？那浪费的空间就相当可观了！</p><p>当然，这个也和使用的内存分配器有关( allocator )：对链表节点的分配和回收会经常发生，这样就不会浪费内存。</p><p>总之，如果链表的元素较大，你也无法预测数组的空间，同时还有一个不错的内存分配器，那链表确实可以节省空间！</p><h4 id="我在函数语言中一直使用链表" tabindex="-1"><a class="header-anchor" href="#我在函数语言中一直使用链表"><span>我在函数语言中一直使用链表</span></a></h4><p>对于函数语言而言，链表确实非常棒，因为你可以解决可变性问题，还能递归地去使用，当然，可能还有一定的图方便的因素，因为链表不用操心长度等问题。</p><p>但彼之蜜糖不等于吾之蜜糖，函数语言的一些使用习惯不应该带入到其它语言中，例如 Rust。</p><ul><li>函数语言往往将链表用于迭代，但是 Rust 中最适合迭代的数据结构是迭代器 <code>Iterator</code></li><li>函数式语言的不可变对于 Rust 也不是问题</li><li>Rust 还支持对数组进行切片以获取其中一部分连续的元素，而在函数语言中你可能得通过链表的 <code>head/tail</code> 分割来完成</li></ul><p>其实，在函数语言中，我们也应该选择合适的数据结构来解决适合的场景，而不是<em>一根链表挂腰间，潇潇洒洒走天下</em>。</p><h4 id="链表适合构建并发数据结构" tabindex="-1"><a class="header-anchor" href="#链表适合构建并发数据结构"><span>链表适合构建并发数据结构</span></a></h4><p>是这样的，如果有这样的需求，那么链表会非常合适！但是只有在你确实需要并发数据结构，且没有其它办法时，再考虑链表！</p><h4 id="链表非常适合教学目的" tabindex="-1"><a class="header-anchor" href="#链表非常适合教学目的"><span>链表非常适合教学目的</span></a></h4><p>额... 这么说也没错，毕竟所有的编程语言课程都以链表来作为最常见的练手项目，包括本书也是服务于这个目的的。</p>',24))])}const k=a(p,[["render",h],["__file","do-we-need-it.html.vue"]]),b=JSON.parse('{"path":"/too-many-lists/do-we-need-it.html","title":"do-we-need-it","lang":"zh-CN","frontmatter":{"description":"我们到底需不需要链表 经常有读者询问该如何实现一个链表，怎么说呢，这个答案主要取决于你的需求，因此并不是很好回答。鉴于此，我决定通过这本书来详尽的介绍该如何实现一个链表，大家应该都能从这本书中找到答案。 书中我们将通过实现 6 种链表来学习基本和进阶 Rust 编程知识，在此过程中，你能学到： 指针类型: &, &mut, Box, Rc, Arc, ...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/too-many-lists/do-we-need-it.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:description","content":"我们到底需不需要链表 经常有读者询问该如何实现一个链表，怎么说呢，这个答案主要取决于你的需求，因此并不是很好回答。鉴于此，我决定通过这本书来详尽的介绍该如何实现一个链表，大家应该都能从这本书中找到答案。 书中我们将通过实现 6 种链表来学习基本和进阶 Rust 编程知识，在此过程中，你能学到： 指针类型: &, &mut, Box, Rc, Arc, ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{},"readingTime":{"minutes":6.34,"words":1902},"filePathRelative":"too-many-lists/do-we-need-it.md","excerpt":"<h2>我们到底需不需要链表</h2>\\n<p>经常有读者询问该如何实现一个链表，怎么说呢，这个答案主要取决于你的需求，因此并不是很好回答。鉴于此，我决定通过这本书来详尽的介绍该如何实现一个链表，大家应该都能从这本书中找到答案。</p>\\n<p>书中我们将通过实现 6 种链表来学习基本和进阶 Rust 编程知识，在此过程中，你能学到：</p>\\n<ul>\\n<li>指针类型: <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>*const</code>, <code>*mut</code>, <code>NonNull</code></li>\\n<li>所有权、借用、继承可变性、内部可变性、Copy</li>\\n<li>所有的关键字：struct、enum、fn、pub、impl、use, ...</li>\\n<li>模式匹配、泛型、解构</li>\\n<li>测试、安装新的工具链、使用 <code>miri</code></li>\\n<li>Unsafe: 裸指针、别名、栈借用、<code>UnsafeCell</code>、变体 variance</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"too-many-lists/do-we-need-it.md","value":{"title":"do-we-need-it","path":"too-many-lists/do-we-need-it.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"too-many-lists/do-we-need-it.md"}]}}}');export{k as comp,b as data};
