import{_ as e,e as a,k as i,o as n}from"./app-D8-td6D_.js";const o={};function c(l,t){return n(),a("div",null,t[0]||(t[0]=[i('<h1 id="实践应用-多线程web服务器" tabindex="-1"><a class="header-anchor" href="#实践应用-多线程web服务器"><span>实践应用：多线程Web服务器</span></a></h1><p>一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。</p><p>在本章中你将了解：</p><ol><li>学习一点 TCP 和 HTTP</li><li>在套接字 socket 上监听进入的 TCP 连接</li><li>解析 HTTP 请求</li><li>创建合适的 HTTP 应答</li><li>使用线程池来提升 web 服务器的吞吐量</li></ol><blockquote><p>本章的实现方法并不是在 Rust 中实现 Web 服务器的最佳方法，后续章节的 async/await 会更加适合!</p></blockquote>',5)]))}const p=e(o,[["render",c],["__file","intro.html.vue"]]),s=JSON.parse('{"path":"/advance-practice1/intro.html","title":"实践应用：多线程Web服务器","lang":"zh-CN","frontmatter":{"description":"实践应用：多线程Web服务器 一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。 在本章中你将了解： 学习一点 TCP 和 HTTP 在套接字 socket 上监听进入的 TCP...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/advance-practice1/intro.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"实践应用：多线程Web服务器"}],["meta",{"property":"og:description","content":"实践应用：多线程Web服务器 一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。 在本章中你将了解： 学习一点 TCP 和 HTTP 在套接字 socket 上监听进入的 TCP..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"实践应用：多线程Web服务器\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{},"readingTime":{"minutes":0.66,"words":199},"filePathRelative":"advance-practice1/intro.md","excerpt":"\\n<p>一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。</p>\\n<p>在本章中你将了解：</p>\\n<ol>\\n<li>学习一点 TCP 和 HTTP</li>\\n<li>在套接字 socket 上监听进入的 TCP 连接</li>\\n<li>解析 HTTP 请求</li>\\n<li>创建合适的 HTTP 应答</li>\\n<li>使用线程池来提升 web 服务器的吞吐量</li>\\n</ol>\\n<blockquote>\\n<p>本章的实现方法并不是在 Rust 中实现 Web 服务器的最佳方法，后续章节的 async/await 会更加适合!</p>\\n</blockquote>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"advance-practice1/intro.md","value":{"title":"intro","path":"advance-practice1/intro.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"advance-practice1/intro.md"}]}}}');export{p as comp,s as data};
