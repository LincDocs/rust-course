import{_ as e,e as r,k as d,o as a}from"./app-D8-td6D_.js";const o={};function n(h,t){return a(),r("div",null,t[0]||(t[0]=[d('<h1 id="快速查询入口" tabindex="-1"><a class="header-anchor" href="#快速查询入口"><span>快速查询入口</span></a></h1><p>&lt;&lt;Rust 语言圣经&gt;&gt; 既然自诩为 Rust 日常开发工具书，那就得有工具书的样子，如果没有了快速索引查询的功能，也就没有了灵魂。</p><p>因此我们决定在这里提供一个对全书内容进行快速索引的途径。理论上来说，<strong>你想查的任何东西在这里都可以快速的被找到并能进入相应的章节查看详细的介绍</strong>。</p><p>可能大家会有疑问，不是有站内搜索功能嘛？是的，但是尴尬的是：首先它不支持中文，其次就算支持了中文，也一样不好用，我们需要的是快速精准地找到内容而不是模糊的查询内容。</p><h1 id="索引列表-doing" tabindex="-1"><a class="header-anchor" href="#索引列表-doing"><span>索引列表 doing</span></a></h1><p><a id="head"></a></p><table><thead><tr><th style="text-align:center;">NN</th><th style="text-align:center;">NN</th><th style="text-align:center;">NN</th><th style="text-align:center;">NN</th><th style="text-align:center;">NN</th><th style="text-align:center;">NN</th><th style="text-align:center;">NN</th><th style="text-align:center;">NN</th><th style="text-align:center;">NN</th></tr></thead><tbody><tr><td style="text-align:center;"><a href="#sym">#</a></td><td style="text-align:center;"><a href="#a">A</a></td><td style="text-align:center;"><a href="#b">B</a></td><td style="text-align:center;"><a href="#c">C</a></td><td style="text-align:center;"><a href="#d">D</a></td><td style="text-align:center;"><a href="#e">E</a></td><td style="text-align:center;"><a href="#f">F</a></td><td style="text-align:center;"><a href="#g">G</a></td><td style="text-align:center;"><a href="#h">H</a></td></tr><tr><td style="text-align:center;"><a href="#i">I</a></td><td style="text-align:center;"><a href="#j">J</a></td><td style="text-align:center;"><a href="#k">K</a></td><td style="text-align:center;"><a href="#l">L</a></td><td style="text-align:center;"><a href="#m">M</a></td><td style="text-align:center;"><a href="#n">N</a></td><td style="text-align:center;"><a href="#o">O</a></td><td style="text-align:center;"><a href="#p">P</a></td><td style="text-align:center;"><a href="#q">Q</a></td></tr><tr><td style="text-align:center;"><a href="#r">R</a></td><td style="text-align:center;"><a href="#s">S</a></td><td style="text-align:center;"><a href="#t">T</a></td><td style="text-align:center;"><a href="#u">U</a></td><td style="text-align:center;"><a href="#v">V</a></td><td style="text-align:center;"><a href="#w">W</a></td><td style="text-align:center;"><a href="#x">X</a></td><td style="text-align:center;"><a href="#y">Y</a></td><td style="text-align:center;"><a href="#z">Z</a></td></tr></tbody></table><table><thead><tr><th style="text-align:center;">NN</th><th style="text-align:center;">NN</th><th style="text-align:center;">NN</th></tr></thead><tbody><tr><td style="text-align:center;"><a href="#cargo">Cargo</a></td><td style="text-align:center;"><a href="https://course.rs/practice/naming.html" target="_blank" rel="noopener noreferrer">Naming</a></td><td style="text-align:center;"><a href="https://course.rs/appendix/keywords.html" target="_blank" rel="noopener noreferrer">Keywords</a></td></tr></tbody></table><p><a href="#bottom">bottom</a></p><h2 id="sym" tabindex="-1"><a class="header-anchor" href="#sym"><span>Sym</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><code>[?]</code></td><td>错误传播</td><td>用于简化错误传播</td></tr><tr><td><code>[()]</code></td><td>单元类型</td><td>单元类型，无返回值</td></tr><tr><td><code>!</code> : 1. [函数] 2. [类型]</td><td>永不返回</td><td>永不返回</td></tr><tr><td><code>[&amp;]</code></td><td>引用</td><td>常规引用是一个指针类型，指向了对象存储的内存地址</td></tr><tr><td><code>[\\*]</code></td><td>解引用</td><td>解出引用所指向的值</td></tr><tr><td><code>[@]</code></td><td>变量绑定</td><td>为一个字段绑定另外一个变量</td></tr><tr><td><code>_</code> : 1. [忽略变量] 2. [模式匹配]</td><td>忽略</td><td>1. 忽略该值或者类型，否则编译器会给你一个 <code>变量未使用的</code> 的警告<br>2. 模式匹配通配符</td></tr><tr><td><code>[&#39;a: &#39;b]</code></td><td>生命周期约束</td><td>用来说明两个生命周期的长短</td></tr><tr><td><code>[{:?}] {:#?}</code></td><td>打印结构体信息</td><td>使用 <code>#[derive(Debug)]</code> 派生实现 <code>Debug</code> 特征，另见 [格式化输出]</td></tr><tr><td><code>[::]</code></td><td>关联函数</td><td>定义在 <code>impl</code> 中且没有 <code>self</code> 的函数</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><code>[?]</code>: https://course.rs/basic/result-error/result.html#传播界的大明星-<br><code>[()]</code>: https://course.rs/basic/base-type/function.html#无返回值<br><code>[函数]</code>: https://course.rs/basic/base-type/function.html#永不返回的发散函数-<br><code>[类型]</code>: https://course.rs/advance/into-types/custom-type.html#永不返回类型<br><code>[&amp;]</code>: https://course.rs/basic/ownership/borrowing.html#引用与解引用<br><code>[\\*]</code>: https://course.rs/basic/ownership/borrowing.html#引用与解引用<br><code>[@]</code>: https://course.rs/basic/match-pattern/all-patterns.html#绑定<br><code>[&#39;a: &#39;b]</code>: https://course.rs/advance/lifetime/advance.html#生命周期约束-hrtb<br><code>[{:?}]</code>: https://course.rs/basic/compound-type/struct.html#使用-derivedebug-来打印结构体的信息<br><code>[忽略变量]</code>: https://course.rs/basic/variable.html#使用下划线开头忽略未使用的变量<br><code>[模式匹配]</code>: https://course.rs/basic/match-pattern/match-if-let.html#_-通配符<br><code>[::]</code>: https://course.rs/basic/method.html#关联函数<br><code>[格式化输出]</code>: https://course.rs/basic/formatted-output.html#-与-</p><p><a href="#head">back</a></p><h2 id="a" tabindex="-1"><a class="header-anchor" href="#a"><span>A</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/compound-type/array.html" target="_blank" rel="noopener noreferrer">array 数组</a></td><td>数组</td><td>长度固定<br>元素必须有相同的类型<br>依次线性排列<br>可以通过索引访问其中的元素<br><code>let a: [i32; 5] = [1, 2, 3, 4, 5];</code></td></tr><tr><td><a href="https://course.rs/basic/compound-type/array.html#%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87" target="_blank" rel="noopener noreferrer">array slice</a></td><td>数组切片</td><td><code>let slice: &amp;[i32] = &amp;a[1..3];</code></td></tr><tr><td><a href="https://course.rs/advance/into-types/converse.html#as%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener noreferrer">as 转换</a></td><td>类型转换</td><td><code>(x as T)</code></td></tr><tr><td></td><td>KWA</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="b" tabindex="-1"><a class="header-anchor" href="#b"><span>B</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/variable.html#%E5%8F%98%E9%87%8F%E9%81%AE%E8%94%BDshadowing" target="_blank" rel="noopener noreferrer">变量遮蔽</a></td><td>shadowing</td><td>允许声明相同的变量名，后者会遮蔽掉前者</td></tr><tr><td><a href="https://course.rs/basic/match-pattern/match-if-let.html#%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96" target="_blank" rel="noopener noreferrer">变量覆盖</a></td><td>模式匹配</td><td>无论是是 <code>match</code> 还是 <code>if let</code>，他们都可以在模式匹配时覆盖掉老的值，绑定新的值</td></tr><tr><td><a href="https://course.rs/basic/ownership/ownership.html#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F" target="_blank" rel="noopener noreferrer">变量作用域</a></td><td>所有权</td><td>作用域是一个变量在程序中有效的范围</td></tr><tr><td><a href="https://course.rs/basic/base-type/statement-expression.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener noreferrer">表达式</a> 与 <a href="https://course.rs/basic/base-type/statement-expression.html#%E8%AF%AD%E5%8F%A5" target="_blank" rel="noopener noreferrer">语句</a></td><td></td><td>表达式：进行求值，结尾无 <code>;</code>，有返回值，如 <code>x + 9</code> 另见 <a href="https://course.rs/appendix/expressions.html" target="_blank" rel="noopener noreferrer">附录 C</a>语句：完成一个操作，结尾有 <code>;</code> ，无返回值，如 <code>let x = 9;</code></td></tr><tr><td><a href="https://course.rs/basic/base-type/char-bool.html#%E5%B8%83%E5%B0%94bool" target="_blank" rel="noopener noreferrer">bool 布尔</a></td><td>布尔类型</td><td><code>true</code> <code>false</code>，占用 1 字节</td></tr><tr><td><a href="https://course.rs/advance/smart-pointer/box.html#%E4%BD%BF%E7%94%A8-boxt-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9C%A8%E5%A0%86%E4%B8%8A" target="_blank" rel="noopener noreferrer">Box&lt;T&gt;</a></td><td>智能指针</td><td>允许你将一个值分配到堆上，然后在栈上保留一个智能指针指向堆上的数据</td></tr><tr><td><a href="https://course.rs/basic/flow-control.html#break" target="_blank" rel="noopener noreferrer">break</a></td><td>循环控制</td><td>直接跳出当前整个循环</td></tr><tr><td><a href="https://course.rs/basic/result-error/panic.html#backtrace-%E6%A0%88%E5%B1%95%E5%BC%80" target="_blank" rel="noopener noreferrer">backtrace 栈展开</a></td><td>不可恢复错误</td><td><code>RUST_BACKTRACE=1 cargo run</code></td></tr><tr><td></td><td>KWB</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="c" tabindex="-1"><a class="header-anchor" href="#c"><span>C</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/base-type/char-bool.html#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8Bchar" target="_blank" rel="noopener noreferrer">char 字符</a></td><td>字符类型</td><td>使用 <code>&#39;&#39;</code> 表示，所有的 Unicode 值</td></tr><tr><td><a href="https://course.rs/basic/variable.html#%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82" target="_blank" rel="noopener noreferrer">const 常量</a></td><td>constant</td><td><code>const MAX_POINTS: u32 = 100_000;</code></td></tr><tr><td><a href="https://course.rs/basic/trait/generic.html#const-%E6%B3%9B%E5%9E%8Brust-151-%E7%89%88%E6%9C%AC%E5%BC%95%E5%85%A5%E7%9A%84%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7" target="_blank" rel="noopener noreferrer">const 泛型</a></td><td>泛型</td><td><code>const N: usize</code> 针对值的泛型，适合处理数组长度的问题</td></tr><tr><td><a href="https://course.rs/basic/trait/generic.html#const-%E6%B3%9B%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener noreferrer">const 泛型表达式</a></td><td>泛型</td><td></td></tr><tr><td><a href="https://course.rs/basic/ownership/ownership.html#%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D" target="_blank" rel="noopener noreferrer">Copy 拷贝</a></td><td>浅拷贝</td><td>任何基本类型的组合可以 <code>Copy</code>，不需要分配内存或某种形式资源的类型是可以 <code>Copy</code> 的。</td></tr><tr><td><a href="https://course.rs/basic/flow-control.html#continue" target="_blank" rel="noopener noreferrer">continue</a></td><td>循环控制</td><td>跳过当前当次的循环，开始下次的循环</td></tr><tr><td><a href="https://course.rs/basic/ownership/ownership.html#%E5%85%8B%E9%9A%86%E6%B7%B1%E6%8B%B7%E8%B4%9D" target="_blank" rel="noopener noreferrer">Clone 克隆</a></td><td>深拷贝</td><td>需要复制堆上的数据时，可以使用 <code>.clone()</code> 方法</td></tr><tr><td><a href="https://course.rs/advance/functional-programing/closure.html" target="_blank" rel="noopener noreferrer">Closure</a></td><td>闭包</td><td>闭包是一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许<a href="https://course.rs/advance/functional-programing/closure.html#%E6%8D%95%E8%8E%B7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%80%BC" target="_blank" rel="noopener noreferrer">捕获调用者作用域中的值</a></td></tr><tr><td></td><td>KWC</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="d" tabindex="-1"><a class="header-anchor" href="#d"><span>D</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/trait/trait.html#%E9%80%9A%E8%BF%87-derive-%E6%B4%BE%E7%94%9F%E7%89%B9%E5%BE%81" target="_blank" rel="noopener noreferrer">derive</a></td><td>派生特征</td><td><code>#[derive(Trait)]</code>，被标记的对象自动实现对应的默认特征<br>详见：<a href="https://course.rs/appendix/derive.html" target="_blank" rel="noopener noreferrer">附录-派生特征</a></td></tr><tr><td><a href="https://course.rs/basic/converse.html#%E7%82%B9%E6%93%8D%E4%BD%9C%E7%AC%A6" target="_blank" rel="noopener noreferrer">点操作符</a></td><td>类型转换</td><td>方法调用的点操作符，在调用时，会发生很多魔法般的类型转换<br>例如：自动引用、自动解引用，强制类型转换直到类型能匹配</td></tr><tr><td><a href="https://course.rs/advance/smart-pointer/deref.html#deref-%E8%A7%A3%E5%BC%95%E7%94%A8" target="_blank" rel="noopener noreferrer">Deref 解引用</a></td><td>智能指针</td><td></td></tr><tr><td><a href="https://course.rs/advance/smart-pointer/deref.html#%E4%B8%89%E7%A7%8D-deref-%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener noreferrer">三种 Deref 转换</a></td><td>智能指针</td><td></td></tr><tr><td><a href="https://course.rs/advance/smart-pointer/drop.html#drop-%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90" target="_blank" rel="noopener noreferrer">Drop 释放资源</a></td><td>智能指针</td><td></td></tr><tr><td></td><td>KWD</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="e" tabindex="-1"><a class="header-anchor" href="#e"><span>E</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/compound-type/enum.html#%E6%9E%9A%E4%B8%BE" target="_blank" rel="noopener noreferrer">enum 枚举</a></td><td>枚举类型</td><td>允许通过列举可能的成员来定义一个枚举类型</td></tr><tr><td><a href="https://course.rs/basic/compound-type/enum.html#%E5%90%8C%E4%B8%80%E5%8C%96%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">enum 同一化类型</a></td><td>枚举方法</td><td>枚举实现方法</td></tr><tr><td></td><td>KWE</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="f" tabindex="-1"><a class="header-anchor" href="#f"><span>F</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/base-type/numbers.html#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">浮点数</a></td><td>数值类型</td><td><code>f32</code><br><code>f64</code>(默认类型)</td></tr><tr><td><a href="https://course.rs/basic/flow-control.html#for-%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">for 循环</a></td><td>循环控制</td><td><code>for item in &amp;collection {}</code></td></tr><tr><td><a href="https://course.rs/basic/base-type/function.html" target="_blank" rel="noopener noreferrer">&#39;fn&#39; 函数</a></td><td></td><td>函数名和变量名使用 <code>蛇形命名法(snake case)</code><br>函数的位置可以随便放<br>每个函数参数都需要标注类型</td></tr><tr><td><a href="https://course.rs/basic/trait/advance-trait.html#%E8%B0%83%E7%94%A8%E5%90%8C%E5%90%8D%E7%9A%84%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">调用同名的方法</a></td><td></td><td>1. 默认调用类型上的方法<br><code>Struct.function(receiver_if_method, next_arg, ...);</code><br>2. 显式调用特征上的方法<br><code>Trait::function(receiver_if_method, next_arg, ...);</code><br>3. <a href="https://course.rs/basic/trait/advance-trait.html#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener noreferrer">完全限定语法</a><br><code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></td></tr><tr><td><a href="https://course.rs/advance/functional-programing/closure.html#%E4%B8%89%E7%A7%8D-fn-%E7%89%B9%E5%BE%81" target="_blank" rel="noopener noreferrer">三种 Fn 特征</a></td><td>闭包</td><td>闭包<a href="https://course.rs/advance/functional-programing/closure.html#%E6%8D%95%E8%8E%B7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%80%BC" target="_blank" rel="noopener noreferrer">捕获变量</a>有三种途径，恰好对应函数参数的三种传入方式：转移所有权、可变借用、不可变借用</td></tr><tr><td><a href="https://course.rs/advance/functional-programing/closure.html#%E4%B8%89%E7%A7%8D-fn-%E7%9A%84%E5%85%B3%E7%B3%BB" target="_blank" rel="noopener noreferrer">三种 Fn 的关系</a></td><td>闭包</td><td></td></tr><tr><td></td><td>KWF</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="g" tabindex="-1"><a class="header-anchor" href="#g"><span>G</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/trait/generic.html" target="_blank" rel="noopener noreferrer">Generics 泛型</a></td><td>泛型</td><td>用同一功能的函数处理不同类型的数据</td></tr><tr><td></td><td>KWG</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="h" tabindex="-1"><a class="header-anchor" href="#h"><span>H</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td>[HashMap]</td><td>哈希类型</td><td><code>HashMap&lt;K, V&gt;</code>，存储的是一一映射的 <code>KV</code> 键值对，并提供了平均复杂度为 <code>O(1)</code> 的查询方法</td></tr><tr><td><a href="https://course.rs/basic/collections/hashmap.html#%E4%BD%BF%E7%94%A8-new-%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA" target="_blank" rel="noopener noreferrer">HashMap::new()</a></td><td></td><td>创建 HashMap，需要手动通过 <code>use std::collections::HashMap;</code> 引入到我们当前的作用域中来</td></tr><tr><td><code>hash.insert(K, V)</code></td><td></td><td>插入键值对，必须声明为 <code>mut</code></td></tr><tr><td><a href="https://course.rs/basic/collections/hashmap.html#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C-collect-%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA" target="_blank" rel="noopener noreferrer">元组创建 HashMap</a></td><td></td><td>使用迭代器和 collect 方法创建<br><code>let teams_map: HashMap&lt;_, _&gt; = teams_list.into_iter().collect();</code></td></tr><tr><td><a href="https://course.rs/basic/collections/hashmap.html#%E6%9F%A5%E8%AF%A2-hashmap" target="_blank" rel="noopener noreferrer">查询 HashMap</a></td><td></td><td>通过 <code>get</code> 方法可以获取元素，返回一个 <code>Option&lt;&amp;T&gt;</code> 类型</td></tr><tr><td><a href="https://course.rs/basic/collections/hashmap.html#%E6%9B%B4%E6%96%B0-hashmap-%E4%B8%AD%E7%9A%84%E5%80%BC" target="_blank" rel="noopener noreferrer">更新 HashMap 中的值</a></td><td></td><td></td></tr><tr><td></td><td>KWH</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="i" tabindex="-1"><a class="header-anchor" href="#i"><span>I</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/flow-control.html#%E4%BD%BF%E7%94%A8-if-%E6%9D%A5%E5%81%9A%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener noreferrer">if else</a></td><td>流程控制</td><td>根据条件执行不同的代码分支</td></tr><tr><td><a href="https://course.rs/basic/flow-control.html#%E4%BD%BF%E7%94%A8-else-if-%E6%9D%A5%E5%A4%84%E7%90%86%E5%A4%9A%E9%87%8D%E6%9D%A1%E4%BB%B6" target="_blank" rel="noopener noreferrer">else if</a></td><td>流程控制</td><td>处理多重条件</td></tr><tr><td><a href="https://course.rs/basic/match-pattern/match-if-let.html#if-let-%E5%8C%B9%E9%85%8D" target="_blank" rel="noopener noreferrer">if let 匹配</a></td><td>模式匹配</td><td>当你只要匹配一个条件，且忽略其他条件时就用 <code>if let</code>，否则都用 <code>match</code></td></tr><tr><td><code>impl Trait</code> 1. <a href="https://course.rs/basic/trait/trait.html#%E4%BD%BF%E7%94%A8%E7%89%B9%E5%BE%81%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" target="_blank" rel="noopener noreferrer">函数参数</a> 2. <a href="https://course.rs/basic/trait/trait.html#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%AD%E7%9A%84-impl-trait" target="_blank" rel="noopener noreferrer">函数返回类型</a></td><td></td><td></td></tr><tr><td></td><td>KWI</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="j" tabindex="-1"><a class="header-anchor" href="#j"><span>J</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td></td><td>KWJ</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="k" tabindex="-1"><a class="header-anchor" href="#k"><span>K</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td></td><td>KWK</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="l" tabindex="-1"><a class="header-anchor" href="#l"><span>L</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/variable.html#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A" target="_blank" rel="noopener noreferrer">let</a></td><td>变量绑定</td><td><code>let x : u32 = 5;</code></td></tr><tr><td><a href="https://course.rs/basic/variable.html#%E5%8F%98%E9%87%8F%E5%8F%AF%E5%8F%98%E6%80%A7" target="_blank" rel="noopener noreferrer">let mut</a></td><td>可变变量</td><td><code>let mut x : u32 = 5; x = 9;</code></td></tr><tr><td><a href="https://course.rs/basic/flow-control.html#loop-%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">loop 循环</a></td><td>循环控制</td><td>无限循环，注意要配合 <a href="https://course.rs/basic/flow-control.html#break" target="_blank" rel="noopener noreferrer"><code>break</code></a></td></tr><tr><td></td><td>KWL</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="m" tabindex="-1"><a class="header-anchor" href="#m"><span>M</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/match-pattern/match-if-let.html#%E6%A8%A1%E5%BC%8F%E7%BB%91%E5%AE%9A" target="_blank" rel="noopener noreferrer">模式绑定</a></td><td>模式匹配</td><td>从模式中取出绑定的值</td></tr><tr><td><a href="https://course.rs/basic/match-pattern/all-patterns.html" target="_blank" rel="noopener noreferrer">全模式列表</a></td><td>模式匹配</td><td>列出了所有的模式匹配</td></tr><tr><td><a href="https://course.rs/basic/method.html#%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">Method 方法</a></td><td><code>impl</code></td><td>Rust 的方法往往跟结构体、枚举、特征一起使用</td></tr><tr><td><a href="https://course.rs/basic/method.html#%E6%96%B9%E6%B3%95%E5%90%8D%E8%B7%9F%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E5%90%8D%E7%9B%B8%E5%90%8C" target="_blank" rel="noopener noreferrer">Method getter</a></td><td><code>getter</code></td><td>方法名跟结构体的字段名相同</td></tr><tr><td><a href="https://course.rs/basic/match-pattern/match-if-let.html#match-%E5%8C%B9%E9%85%8D" target="_blank" rel="noopener noreferrer">match 匹配</a></td><td>模式匹配</td><td>1. <code>match</code> 的匹配必须要穷举出所有可能，因此这里用 <code>_ </code> 来代表未列出的所有可能性<br>2. <code>match</code> 的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同</td></tr><tr><td><a href="https://course.rs/basic/match-pattern/match-if-let.html#matches%E5%AE%8F" target="_blank" rel="noopener noreferrer">matches! 宏</a></td><td>模式匹配</td><td>将一个表达式跟模式进行匹配，然后返回匹配的结果 <code>true</code> 或 <code>false</code></td></tr><tr><td><a href="https://course.rs/basic/match-pattern/all-patterns.html#%E5%8C%B9%E9%85%8D%E5%AE%88%E5%8D%AB%E6%8F%90%E4%BE%9B%E7%9A%84%E9%A2%9D%E5%A4%96%E6%9D%A1%E4%BB%B6" target="_blank" rel="noopener noreferrer">match guard</a></td><td>匹配守卫</td><td>位于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它能为分支模式提供更进一步的匹配条件</td></tr><tr><td><a href="https://course.rs/basic/ownership/ownership.html#%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83" target="_blank" rel="noopener noreferrer">move 移动</a></td><td>转移所有权</td><td><code>let s2 = s1;</code><br><code>s1</code> 所有权转移给了 <code>s2</code>，<code>s1</code> 失效</td></tr><tr><td></td><td>KWM</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="n" tabindex="-1"><a class="header-anchor" href="#n"><span>N</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/trait/advance-trait.html#%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E7%89%B9%E5%BE%81newtype" target="_blank" rel="noopener noreferrer">newtype for Trait</a></td><td>newtype</td><td>为一个<a href="https://course.rs/basic/compound-type/struct.html#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93tuple-struct" target="_blank" rel="noopener noreferrer">元组结构体</a>创建新类型。该元组结构体封装有一个字段，该字段就是希望实现特征的具体类型</td></tr><tr><td><a href="http://localhost:8080/advance/into-types/custom-type.html#newtype" target="_blank" rel="noopener noreferrer">newtype </a></td><td>newtype</td><td>深入 Rust 类型</td></tr><tr><td></td><td>KWN</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="o" tabindex="-1"><a class="header-anchor" href="#o"><span>O</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/compound-type/enum.html#option-%E6%9E%9A%E4%B8%BE%E7%94%A8%E4%BA%8E%E5%A4%84%E7%90%86%E7%A9%BA%E5%80%BC" target="_blank" rel="noopener noreferrer">Option</a></td><td>Option 枚举</td><td>用于处理空值，<strong>一个变量要么有值：<code>Some(T)</code>, 要么为空：<code>None</code></strong></td></tr><tr><td><a href="https://course.rs/basic/match-pattern/option.html#%E5%8C%B9%E9%85%8D-optiont" target="_blank" rel="noopener noreferrer">Option 解构</a></td><td>模式匹配</td><td>可以通过 <code>match</code> 来实现</td></tr><tr><td></td><td>KWO</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="p" tabindex="-1"><a class="header-anchor" href="#p"><span>P</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/result-error/panic.html#panic-%E4%B8%8E%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E9%94%99%E8%AF%AF" target="_blank" rel="noopener noreferrer">panic! 不可恢复错误</a></td><td>不可恢复错误</td><td>程序会打印出一个错误信息，展开报错点往前的函数调用堆栈，最后退出程序</td></tr><tr><td><a href="https://course.rs/basic/result-error/panic.html#panic-%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90" target="_blank" rel="noopener noreferrer">panic 原理剖析</a></td><td>不可恢复错误</td><td></td></tr><tr><td><a href="https://course.rs/basic/formatted-output.html#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8F%82%E6%95%B0" target="_blank" rel="noopener noreferrer">println!</a></td><td>格式化参数</td><td>对输出内容格式有更多要求</td></tr><tr><td></td><td>KWP</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="q" tabindex="-1"><a class="header-anchor" href="#q"><span>Q</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td></td><td>KWQ</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="r" tabindex="-1"><a class="header-anchor" href="#r"><span>R</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/base-type/numbers.html#%E5%BA%8F%E5%88%97range" target="_blank" rel="noopener noreferrer">Range 序列</a></td><td></td><td>生成连续的数值<br> 只允许用于数字或字符类型<br> <code>..</code> 右半开区间 <br><code>..=</code> 闭合区间</td></tr><tr><td><a href="https://course.rs/basic/result-error/result.html#%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF-result" target="_blank" rel="noopener noreferrer">Result 可恢复的错误</a></td><td>可恢复错误</td><td><code>enum Result&lt;T, E&gt; { Ok(T), Err(E), }</code></td></tr><tr><td><a href="https://course.rs/basic/result-error/result.html#%E5%AF%B9%E8%BF%94%E5%9B%9E%E7%9A%84%E9%94%99%E8%AF%AF%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86" target="_blank" rel="noopener noreferrer">对返回的错误进行处理</a></td><td>可恢复错误</td><td>对返回的错误进行处理</td></tr><tr><td></td><td>KWR</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="s" tabindex="-1"><a class="header-anchor" href="#s"><span>S</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/ownership/ownership.html#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%A0%86%E6%A0%88" target="_blank" rel="noopener noreferrer">所有权与堆栈</a></td><td></td><td>Rust 所有权提供的强大保障</td></tr><tr><td><a href="https://course.rs/basic/ownership/ownership.html#%E6%89%80%E6%9C%89%E6%9D%83%E5%8E%9F%E5%88%99" target="_blank" rel="noopener noreferrer">所有权原则</a></td><td></td><td>Rust 中每一个值都 <code>有且只有</code> 一个所有者(变量)<br> 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)</td></tr><tr><td><a href="https://course.rs/basic/compound-type/string-slice.html#%E5%88%87%E7%89%87slice" target="_blank" rel="noopener noreferrer">slice 切片</a></td><td><code>&amp;str</code></td><td>允许你引用 <code>String</code> 中部分连续的元素序列，而不是引用整个 <code>String</code> <br>语法：<code>[开始索引..终止索引]</code><br>字符串字面量是切片</td></tr><tr><td><a href="https://course.rs/basic/compound-type/string-slice.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener noreferrer">String 字符串</a></td><td><code>String</code> 类型</td><td>Rust 中的字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)</td></tr><tr><td><a href="https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener noreferrer">String 操作</a></td><td><code>String</code> 方法</td><td>由于 <code>String</code> 是可变字符串，因此我们可以对它进行创建、增删操作</td></tr><tr><td><a href="https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89" target="_blank" rel="noopener noreferrer">String 转义</a></td><td><code>String</code> 方法</td><td>通过转义的方式 <code>\\</code> 输出 ASCII 和 Unicode 字符</td></tr><tr><td><a href="https://course.rs/basic/compound-type/struct.html" target="_blank" rel="noopener noreferrer">struct 结构体</a></td><td>结构体</td><td>通过关键字 <code>struct</code> 定义<br>一个清晰明确的结构体 <code>名称</code><br>几个有名字的结构体 <code>字段</code><br>通过 <code>.</code> 访问字段</td></tr><tr><td><a href="https://course.rs/basic/method.html#selfself-%E5%92%8C-mut-self" target="_blank" rel="noopener noreferrer">self &amp;self &amp;mut self</a></td><td>Method 方法</td><td><code>self</code> 指代类型的实例</td></tr><tr><td><a href="https://course.rs/basic/trait/trait-object#self-%E4%B8%8E-self" target="_blank" rel="noopener noreferrer">Self 与 self</a></td><td></td><td><code>self</code> 指代当前的实例对象，<code>Self</code> 指代特征或者方法类型的别名</td></tr><tr><td><a href="https://course.rs/basic/lifetime.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener noreferrer">生命周期标注语法</a></td><td>生命周期</td><td><code>&amp;&#39;a i32</code></td></tr><tr><td><a href="https://course.rs/basic/lifetime.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B6%88%E9%99%A4" target="_blank" rel="noopener noreferrer">生命周期消除</a></td><td>生命周期</td><td></td></tr><tr><td><a href="https://course.rs/advance/lifetime/advance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B6%88%E9%99%A4%E8%A7%84%E5%88%99%E8%A1%A5%E5%85%85" target="_blank" rel="noopener noreferrer">生命周期消除规则补充</a></td><td>生命周期</td><td></td></tr><tr><td><a href="https://course.rs/basic/lifetime.html#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener noreferrer">函数中的生命周期</a></td><td>生命周期</td><td></td></tr><tr><td><a href="https://course.rs/basic/lifetime.html#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener noreferrer">结构体中的生命周期</a></td><td>生命周期</td><td></td></tr><tr><td><a href="https://course.rs/basic/lifetime.html#%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener noreferrer">方法中的生命周期</a></td><td>生命周期</td><td></td></tr><tr><td><a href="https://course.rs/basic/lifetime.html#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener noreferrer">静态生命周期</a></td><td>生命周期</td><td><code>&amp;&#39;static</code> 拥有该生命周期的引用可以和整个程序活得一样久，另见 <a href="https://course.rs/advance/lifetime/static.html" target="_blank" rel="noopener noreferrer">&amp;&#39;static 和 T: &#39;static</a></td></tr><tr><td></td><td>KWS</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="t" tabindex="-1"><a class="header-anchor" href="#t"><span>T</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/compound-type/tuple.html#%E5%85%83%E7%BB%84" target="_blank" rel="noopener noreferrer">Tuple 元组</a></td><td></td><td>由多种类型组合一起，元组的长度是固定的，元组中元素的顺序也是固定的<br>用模式匹配解构元组：<code>let (x, y, z) = (20, 19.2, 1)</code><br>用 <code>.</code> 来访问元组：<code>tuple.0</code> 索引从 0 开始</td></tr><tr><td><a href="https://course.rs/basic/compound-type/struct.html#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93tuple-struct" target="_blank" rel="noopener noreferrer">Tuple Struct</a></td><td>元组结构体</td><td>结构体必须要有名称，但字段可以没有名称<br><code>struct Color(i32, i32, i32);</code></td></tr><tr><td><a href="https://course.rs/basic/trait/trait.html#%E5%AE%9A%E4%B9%89%E7%89%B9%E5%BE%81" target="_blank" rel="noopener noreferrer">Trait 特征</a></td><td>特征</td><td>一个可以被共享的行为，只要实现了特征，你就能使用该行为</td></tr><tr><td><a href="https://course.rs/basic/trait/trait.html#%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9Ftrait-bound" target="_blank" rel="noopener noreferrer">T: Trait</a></td><td>特征约束</td><td>还可以有多重约束，<code>T: Trait1 + Trait2</code><br>另见：<a href="https://course.rs/basic/trait/trait.html#where-%E7%BA%A6%E6%9D%9F" target="_blank" rel="noopener noreferrer">where 约束</a></td></tr><tr><td><a href="https://course.rs/basic/trait/trait-object.html#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener noreferrer">Trait Object</a></td><td>特征对象</td><td>特征对象指向实现了 <code>Trait</code> 特征的类型的实例，可以在运行时通过特征对象找到具体调用的类型方法</td></tr><tr><td><code>type</code> 1. <a href="https://course.rs/basic/trait/advance-trait.html#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">关联类型</a> 2. <a href="https://course.rs/basic/trait/advance-trait.html#%E9%BB%98%E8%AE%A4%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0" target="_blank" rel="noopener noreferrer">默认泛型类型参数</a> 3. <a href="https://course.rs/advance/into-types/custom-type.html#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8Dtype-alias" target="_blank" rel="noopener noreferrer">类型别名</a></td><td></td><td>1. <code>type Item;</code><br><code>Self</code> 用来指代当前调用者的具体类型，那么 <code>Self::em</code> 就用来指代该类型实现中定义的 <code>Item</code> 类型<br>2. <code>type Output = Struct;</code><br>指定一个默认值，返回一个关联类型 <code>Output</code></td></tr><tr><td><a href="https://course.rs/basic/trait/advance-trait.html#%E7%89%B9%E5%BE%81%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F" target="_blank" rel="noopener noreferrer">特征定义中的特征约束</a></td><td>特征</td><td>用来说明一个特征需要实现另一个特征</td></tr><tr><td><a href="https://course.rs/advance/into-types/converse.html#tryinto-%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener noreferrer">TryInto 转换</a></td><td>类型转换</td><td>尝试进行一次转换，并返回一个 <code>Result</code>，可以对其进行相应的错误处理</td></tr><tr><td></td><td>KWT</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="u" tabindex="-1"><a class="header-anchor" href="#u"><span>U</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/compound-type/struct.html#%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93unit-like-struct" target="_blank" rel="noopener noreferrer">Unit-like Struct</a></td><td>单元结构体</td><td>没有任何字段和属性<br><code>struct AlwaysEqual;</code></td></tr><tr><td><a href="https://course.rs/basic/result-error/result.html#%E5%A4%B1%E8%B4%A5%E5%B0%B1-panic-unwrap-%E5%92%8C-expect" target="_blank" rel="noopener noreferrer">unwrap &amp; expect</a></td><td>可恢复错误</td><td>如果返回成功，就将 <code>Ok(T)</code> 中的值取出来，如果失败，就直接 <code>panic</code></td></tr><tr><td></td><td>KWU</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="v" tabindex="-1"><a class="header-anchor" href="#v"><span>V</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/collections/vector.html" target="_blank" rel="noopener noreferrer">Vector 动态数组</a></td><td>动态数组</td><td><code>Vec&lt;T&gt;</code>，动态数组允许你存储多个值，这些值在内存中一个紧挨着另一个排列。只能存储相同类型的元素</td></tr><tr><td><a href="https://course.rs/basic/collections/vector.html#vecnew" target="_blank" rel="noopener noreferrer">Vec::new</a></td><td></td><td>创建动态数组</td></tr><tr><td><a href="https://course.rs/basic/collections/vector.html#vec" target="_blank" rel="noopener noreferrer">vec![]</a></td><td></td><td>创建动态数组，能在创建时给予初始化值</td></tr><tr><td><a href="https://course.rs/basic/collections/vector.html#%E6%9B%B4%E6%96%B0-vector" target="_blank" rel="noopener noreferrer">vec.push</a></td><td></td><td>向数组尾部添加元素，必须声明为 <code>mut</code></td></tr><tr><td><a href="https://course.rs/basic/collections/vector.html#%E4%BB%8E-vector-%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%85%83%E7%B4%A0" target="_blank" rel="noopener noreferrer">vec.get</a></td><td></td><td>从 Vector 中读取元素，返回 <code>Option&lt;&amp;T&gt;</code></td></tr><tr><td><code>&amp;vec[index]</code></td><td></td><td>从 Vector 中读取元素，使用下标索引访问，从 0 开始</td></tr><tr><td><a href="https://course.rs/basic/collections/vector.html#%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86-vector-%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0" target="_blank" rel="noopener noreferrer">迭代遍历 Vector 中的元素</a></td><td></td><td>如果想要依次访问数组中的元素，可以使用迭代的方式去遍历数组</td></tr><tr><td><a href="https://course.rs/basic/collections/vector.html#%E5%AD%98%E5%82%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%83%E7%B4%A0" target="_blank" rel="noopener noreferrer">存储不同类型的元素</a></td><td></td><td>通过使用枚举类型和特征对象来实现不同类型元素的存储</td></tr><tr><td></td><td>KWV</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="w" tabindex="-1"><a class="header-anchor" href="#w"><span>W</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/flow-control.html#while-%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">while 循环</a></td><td>循环控制</td><td>当条件为 <code>true</code> 时，继续循环，条件为 <code>false</code>，跳出循环</td></tr><tr><td><a href="https://course.rs/basic/trait/trait.html#where-%E7%BA%A6%E6%9D%9F" target="_blank" rel="noopener noreferrer">where 约束</a></td><td>特征约束</td><td>当特征约束变多时，函数签名会很复杂，可以用 <code>where</code> 做形式上的改进</td></tr><tr><td></td><td>KWW</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="x" tabindex="-1"><a class="header-anchor" href="#x"><span>X</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td></td><td>KWX</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="y" tabindex="-1"><a class="header-anchor" href="#y"><span>Y</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td></td><td>KWY</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="z" tabindex="-1"><a class="header-anchor" href="#z"><span>Z</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://course.rs/basic/base-type/numbers.html#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">整数</a></td><td>数值类型</td><td>有符号整数，<code>i8</code>，<code>i16</code>，<code>i32</code>，<code>i64</code>，<code>i128</code>，<code>isize</code><br>无符号整数，<code>u8</code>，<code>u16</code>，<code>u32</code>，<code>u64</code>，<code>u128</code>，<code>usize</code></td></tr><tr><td><a href="https://course.rs/basic/base-type/numbers.html#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">整形字面量</a></td><td>进制书写</td><td>十进制 <code>98_222</code><br>十六进制 <code>0xff</code><br>八进制 <code>0o77</code><br>二进制 <code>0b1111_0000</code><br>字节(仅限于<code>u8</code>) <code>b&#39;A&#39;</code></td></tr><tr><td></td><td>KWZ</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><h2 id="cargo" tabindex="-1"><a class="header-anchor" href="#cargo"><span>Cargo</span></a></h2><table><thead><tr><th>名称</th><th>关键字</th><th>简介</th></tr></thead><tbody><tr><td>Cargo</td><td>KWCG</td><td></td></tr></tbody></table><p><a href="#head">back</a></p><p><a id="bottom"></a></p>',95)]))}const s=e(o,[["render",n],["__file","index-list.html.vue"]]),l=JSON.parse('{"path":"/index-list.html","title":"快速查询入口","lang":"zh-CN","frontmatter":{"description":"快速查询入口 <<Rust 语言圣经>> 既然自诩为 Rust 日常开发工具书，那就得有工具书的样子，如果没有了快速索引查询的功能，也就没有了灵魂。 因此我们决定在这里提供一个对全书内容进行快速索引的途径。理论上来说，你想查的任何东西在这里都可以快速的被找到并能进入相应的章节查看详细的介绍。 可能大家会有疑问，不是有站内搜索功能嘛？是的，但是尴尬的是：...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/index-list.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"快速查询入口"}],["meta",{"property":"og:description","content":"快速查询入口 <<Rust 语言圣经>> 既然自诩为 Rust 日常开发工具书，那就得有工具书的样子，如果没有了快速索引查询的功能，也就没有了灵魂。 因此我们决定在这里提供一个对全书内容进行快速索引的途径。理论上来说，你想查的任何东西在这里都可以快速的被找到并能进入相应的章节查看详细的介绍。 可能大家会有疑问，不是有站内搜索功能嘛？是的，但是尴尬的是：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"快速查询入口\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{},"readingTime":{"minutes":16.61,"words":4983},"filePathRelative":"index-list.md","excerpt":"\\n<p>&lt;&lt;Rust 语言圣经&gt;&gt; 既然自诩为 Rust 日常开发工具书，那就得有工具书的样子，如果没有了快速索引查询的功能，也就没有了灵魂。</p>\\n<p>因此我们决定在这里提供一个对全书内容进行快速索引的途径。理论上来说，<strong>你想查的任何东西在这里都可以快速的被找到并能进入相应的章节查看详细的介绍</strong>。</p>\\n<p>可能大家会有疑问，不是有站内搜索功能嘛？是的，但是尴尬的是：首先它不支持中文，其次就算支持了中文，也一样不好用，我们需要的是快速精准地找到内容而不是模糊的查询内容。</p>\\n<h1>索引列表 doing</h1>\\n<p><a id=\\"head\\"></a></p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[],"localMap":{"nodes":[{"id":"index-list.md","value":{"title":"index-list","path":"index-list.md","outlink":[],"backlink":[]}}],"links":[]}}}');export{s as comp,l as data};
