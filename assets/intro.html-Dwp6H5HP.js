import{_ as s,e as a,f as n,o as i}from"./app-DFfX2bp8.js";const t={};function d(c,e){return i(),a("div",null,e[0]||(e[0]=[n(`<h1 id="unsafe-简介" tabindex="-1"><a class="header-anchor" href="#unsafe-简介"><span>unsafe 简介</span></a></h1><p>圣人论迹不论心，论心世上无圣人，对于编程语言而言，亦是如此。</p><p>虽然在本章之前，我们学到的代码都是在编译期就得到了 Rust 的安全保障，但是在其内心深处也隐藏了一些阴暗面，在这些阴暗面里，内存安全就存在一些变数了：当不娴熟的开发者接触到这些阴暗面，就可能写出不安全的代码，因此我们称这种代码为 <code>unsafe</code> 代码块。</p><h2 id="为何会有-unsafe" tabindex="-1"><a class="header-anchor" href="#为何会有-unsafe"><span>为何会有 unsafe</span></a></h2><p>几乎每个语言都有 <code>unsafe</code> 关键字，但 Rust 语言使用 <code>unsafe</code> 的原因可能与其它编程语言还有所不同。</p><h4 id="过强的编译器" tabindex="-1"><a class="header-anchor" href="#过强的编译器"><span>过强的编译器</span></a></h4><p>说来尴尬，<code>unsafe</code> 的存在主要是因为 Rust 的静态检查太强了，但是强就算了，它还很保守，这就会导致当编译器在分析代码时，一些正确代码会因为编译器无法分析出它的所有正确性，结果将这段代码拒绝，导致编译错误。</p><p>这种保守的选择确实也没有错，毕竟安全就是要防微杜渐，但是对于使用者来说，就不是那么愉快的事了，特别是当配合 Rust 的所有权系统一起使用时，有个别问题是真的棘手和难以解决。</p><p>举个例子，在之前的自引用章节中，我们就提到了相关的编译检查是很难绕过的，如果想要绕过，最常用的方法之一就是使用 <a href="https://course.rs/advance/circle-self-ref/self-referential.html" target="_blank" rel="noopener noreferrer"><code>unsafe</code> 和 <code>Pin</code></a>。</p><p>好在，当遇到这些情况时，我们可以使用 <code>unsafe</code> 来解决。此时，你需要替代编译器的部分职责对 <code>unsafe</code> 代码的正确性负责，例如在正常代码中不可能遇到的空指针解引用问题在 <code>unsafe</code> 中就可能会遇到，我们需要自己来处理好这些类似的问题。</p><h4 id="特定任务的需要" tabindex="-1"><a class="header-anchor" href="#特定任务的需要"><span>特定任务的需要</span></a></h4><p>至于 <code>unsafe</code> 存在的另一个原因就是：它必须要存在。原因是计算机底层的一些硬件就是不安全的，如果 Rust 只允许你做安全的操作，那一些任务就无法完成，换句话说，我们还怎么跟 C++ 干架？</p><p>Rust 的一个主要定位就是系统编程，众所周知，系统编程就是底层编程，往往需要直接跟操作系统打交道，甚至于去实现一个操作系统。而为了实现底层系统编程，<code>unsafe</code> 就是必不可少的。</p><p>在了解了为何会有 <code>unsafe</code> 后，我们再来看看，除了这些必要性，<code>unsafe</code> 还能给我们带来哪些超能力。</p><h2 id="unsafe-的超能力" tabindex="-1"><a class="header-anchor" href="#unsafe-的超能力"><span>unsafe 的超能力</span></a></h2><p>使用 <code>unsafe</code> 非常简单，只需要将对应的代码块标记下即可:</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> num</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> r1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">num</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> as</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> *</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;r1 is: {}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, *</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">r1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中, <code>r1</code> 是一个裸指针(raw pointer)，由于它具有破坏 Rust 内存安全的潜力，因此只能在 <code>unsafe</code> 代码块中使用，如果你去掉 <code>unsafe {}</code>，编译器会立刻报错。</p><p>言归正传， <code>unsafe</code> 能赋予我们 5 种超能力，这些能力在安全的 Rust 代码中是无法获取的：</p><ul><li>解引用裸指针，就如上例所示</li><li>调用一个 <code>unsafe</code> 或外部的函数</li><li>访问或修改一个可变的<a href="https://course.rs/advance/global-variable.html#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F" target="_blank" rel="noopener noreferrer">静态变量</a></li><li>实现一个 <code>unsafe</code> 特征</li><li>访问 <code>union</code> 中的字段</li></ul><p>在本章中，我们将着重讲解裸指针和 FFI 的使用。</p><h2 id="unsafe-的安全保证" tabindex="-1"><a class="header-anchor" href="#unsafe-的安全保证"><span>unsafe 的安全保证</span></a></h2><p>曾经在 <code>reddit</code> 上有一个讨论还挺热闹的，是关于 <code>unsafe</code> 的命名是否合适，总之公有公理，婆有婆理，但有一点是不可否认的：虽然名称自带不安全，但是 Rust 依然提供了强大的安全支撑。</p><p>首先，<code>unsafe</code> 并不能绕过 Rust 的借用检查，也不能关闭任何 Rust 的安全检查规则，例如当你在 <code>unsafe</code> 中使用<strong>引用</strong>时，该有的检查一样都不会少。</p><p>因此 <code>unsafe</code> 能给大家提供的也仅仅是之前的 5 种超能力，在使用这 5 种能力时，编译器才不会进行内存安全方面的检查，最典型的就是使用<strong>裸指针</strong>(引用和裸指针有很大的区别)。</p><h2 id="谈虎色变" tabindex="-1"><a class="header-anchor" href="#谈虎色变"><span>谈虎色变？</span></a></h2><p>在网上充斥着这样的言论：<code>千万不要使用 unsafe，因为它不安全</code>，甚至有些库会以没有 <code>unsafe</code> 代码作为噱头来吸引用户。事实上，大可不必，如果按照这个标准，Rust 的标准库也将不复存在！</p><p>Rust 中的 <code>unsafe</code> 其实没有那么可怕，虽然听上去很不安全，但是实际上 Rust 依然提供了很多机制来帮我们提升了安全性，因此不必像对待 Go 语言的 <code>unsafe</code> 那样去畏惧于使用 Rust 中的 <code>unsafe</code> 。</p><p>大致使用原则总结如下：没必要用时，就不要用，当有必要用时，就大胆用，但是尽量控制好边界，让 <code>unsafe</code> 的范围尽可能小。</p><h2 id="控制-unsafe-的使用边界" tabindex="-1"><a class="header-anchor" href="#控制-unsafe-的使用边界"><span>控制 unsafe 的使用边界</span></a></h2><p><code>unsafe</code> 不安全，但是该用的时候就要用，在一些时候，它能帮助我们大幅降低代码实现的成本。</p><p>而作为使用者，你的水平决定了 <code>unsafe</code> 到底有多不安全，因此你需要在 <code>unsafe</code> 中小心谨慎地去访问内存。</p><p>即使做到小心谨慎，依然会有出错的可能性，但是 <code>unsafe</code> 语句块决定了：就算内存访问出错了，你也能立刻意识到，错误是在 <code>unsafe</code> 代码块中，而不花大量时间像无头苍蝇一样去寻找问题所在。</p><p>正因为此，写代码时要尽量控制好 <code>unsafe</code> 的边界大小，越小的 <code>unsafe</code> 越会让我们在未来感谢自己当初的选择。</p><p>除了控制边界大小，另一个很常用的方式就是在 <code>unsafe</code> 代码块外包裹一层 <code>safe</code> 的 API，例如一个函数声明为 safe 的，然后在其内部有一块儿是 <code>unsafe</code> 代码。</p><blockquote><p>忍不住抱怨一句，内存安全方面的 bug ，是真心难查！</p></blockquote>`,36)]))}const p=s(t,[["render",d],["__file","intro.html.vue"]]),r=JSON.parse('{"path":"/src/advance/unsafe/intro.html","title":"unsafe 简介","lang":"zh-CN","frontmatter":{"description":"unsafe 简介 圣人论迹不论心，论心世上无圣人，对于编程语言而言，亦是如此。 虽然在本章之前，我们学到的代码都是在编译期就得到了 Rust 的安全保障，但是在其内心深处也隐藏了一些阴暗面，在这些阴暗面里，内存安全就存在一些变数了：当不娴熟的开发者接触到这些阴暗面，就可能写出不安全的代码，因此我们称这种代码为 unsafe 代码块。 为何会有 uns...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/src/advance/unsafe/intro.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"unsafe 简介"}],["meta",{"property":"og:description","content":"unsafe 简介 圣人论迹不论心，论心世上无圣人，对于编程语言而言，亦是如此。 虽然在本章之前，我们学到的代码都是在编译期就得到了 Rust 的安全保障，但是在其内心深处也隐藏了一些阴暗面，在这些阴暗面里，内存安全就存在一些变数了：当不娴熟的开发者接触到这些阴暗面，就可能写出不安全的代码，因此我们称这种代码为 unsafe 代码块。 为何会有 uns..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-24T15:57:50.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-24T15:57:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"unsafe 简介\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-24T15:57:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{"createdTime":1745510270000,"updatedTime":1745510270000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":5.21,"words":1564},"filePathRelative":"src/advance/unsafe/intro.md","localizedDate":"2025年4月24日","excerpt":"\\n<p>圣人论迹不论心，论心世上无圣人，对于编程语言而言，亦是如此。</p>\\n<p>虽然在本章之前，我们学到的代码都是在编译期就得到了 Rust 的安全保障，但是在其内心深处也隐藏了一些阴暗面，在这些阴暗面里，内存安全就存在一些变数了：当不娴熟的开发者接触到这些阴暗面，就可能写出不安全的代码，因此我们称这种代码为 <code>unsafe</code> 代码块。</p>\\n<h2>为何会有 unsafe</h2>\\n<p>几乎每个语言都有 <code>unsafe</code> 关键字，但 Rust 语言使用 <code>unsafe</code> 的原因可能与其它编程语言还有所不同。</p>\\n<h4>过强的编译器</h4>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"src/SUMMARY.html"}],"localMap":{"nodes":[{"id":"src/advance/unsafe/intro.md","value":{"title":"intro","path":"src/advance/unsafe/intro.md","outlink":[],"backlink":["src/SUMMARY.md"]}},{"id":"src/SUMMARY.md","value":{"title":"SUMMARY","path":"src/SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"src/SUMMARY.md","target":"src/advance/unsafe/intro.md"}]}}}');export{p as comp,r as data};
