import{_ as i,e as a,k as n,o as e}from"./app-Ca5AIWu9.js";const t={};function l(h,s){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="rust-新版解读-1-63-重点-scoped-threads" tabindex="-1"><a class="header-anchor" href="#rust-新版解读-1-63-重点-scoped-threads"><span>Rust 新版解读 | 1.63 | 重点: Scoped threads</span></a></h1><blockquote><p>Rust 1.63 官方 release doc: <a href="https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html" target="_blank" rel="noopener noreferrer">Announcing Rust 1.63.0 | Rust Blog</a></p></blockquote><p>通过 <a href="https://www.rust-lang.org/tools/install" target="_blank" rel="noopener noreferrer">rustup</a> 安装的同学可以使用以下命令升级到 1.63 版本:</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rustup</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> update</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> stable</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="区域线程-scoped-threads" tabindex="-1"><a class="header-anchor" href="#区域线程-scoped-threads"><span>区域线程 Scoped threads</span></a></h2><p>Rust 从 1.0 版本起，就可以使用 <code>std::thread::spawn</code> 来创建一个线程，但是这个函数要求了其生成的线程必须拥有任何传递进去的参数的所有权，也就是说你不能把引用数据传递进去。在一些线程会在方法末尾退出的情况下（通常使用 <code>join()</code> 方法），这个严格的约束显得不必要，在此之前也通常使用 <code>Arc</code> 包裹数据的的方法来妥协。</p><p>随着 1.63 版本的推出，标准库新增了<strong>区域线程</strong>，允许在区域 <code>scope</code> 内创建使用当前调用栈内引用数据的线程。<code>std::thread::scope</code> 的API保证其中创建的线程会在自身返回前推出，也就允许安全的借用数据。看下面的例子，在 <code>scope</code> 内创建两个线程来，分别借用了数据：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> vec!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">scope</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">|</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">s</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">|</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">spawn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">||</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello from the first scoped thread&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 可以借用变量 \`a\`</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        dbg!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    });</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">spawn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">||</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello from the second scoped thread&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 没有其它线程在使用，所以也可以可变借用 \`x\`</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        x</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +=</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] + </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    });</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello from the main thread&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Scope 退出后，可以继续修改、访问变量。</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">assert_eq!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">len</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="rust-对原始文件描述符-句柄的所有权" tabindex="-1"><a class="header-anchor" href="#rust-对原始文件描述符-句柄的所有权"><span>Rust 对原始文件描述符/句柄的所有权</span></a></h2><p>之前 Rust 代码在使用平台相关 API ，涉及到文件描述符（file descriptor on unix）或句柄（handles on windows）的时候，都是直接使用对应的描述符（比如，<code>c_int</code> alias <code>RawFd</code>）。因此类型系统无法判断 API 是会获取文件描述符的所有权，还是仅仅借用它。</p><p>现在，Rust 提供了封装类型诸如 <code>BorrowedFd</code> 和 <code>OwnedFd</code>。这些封装类型都标记为了 <code>#[repr(transparent)]</code>，意味着 <code>extern &quot;C&quot;</code> 绑定下也可以直接使用这些类型来编码所有权语义。完整的封装类型参见原文下的 <a href="https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html#stabilized-apis" target="_blank" rel="noopener noreferrer">stabilized apis in 1.63</a></p><h2 id="mutex-rwlock-condvar-作为静态变量" tabindex="-1"><a class="header-anchor" href="#mutex-rwlock-condvar-作为静态变量"><span><code>Mutex</code>, <code>RwLock</code>, <code>Condvar</code> 作为静态变量</span></a></h2><p><code>Condvar::new</code>, <code>Mutex::new</code> 和 <code>RwLock::new</code> 可以在 <code>const</code> 上下文里被调用了，不必再使用 <code>lazy_static</code> 库来写全局静态的 <code>Mutex</code>, <code>RwLock</code>, <code>Condvar</code> 了。</p><h2 id="turbofish-可用于含有-impl-trait-的泛型函数上" tabindex="-1"><a class="header-anchor" href="#turbofish-可用于含有-impl-trait-的泛型函数上"><span>Turbofish 可用于含有 <code>impl Trait</code> 的泛型函数上</span></a></h2><p>诸如 <code>fn foo&lt;T&gt;(value: T, f: impl Copy)</code> 的函数签名，使用 Turbofish <code>foo::&lt;u32&gt;(3,3)</code> 来指定 <code>T</code> 的具体类型会出现编译错误：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">error[E0632]:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cannot</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> provide</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> explicit</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> generic</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> arguments</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> when</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">impl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Trait\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> is</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> used</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> in</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> argument</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> position</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> --</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">src/lib.rs:4:11</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  |</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> |     </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">foo::</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;u32&gt;(3, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  |           </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">^^^</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> explicit</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> generic</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> argument</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> not</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> allowed</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  |</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> note:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> see</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> issue</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #83701 &lt;https://github.com/rust-lang/rust/issues/83701&gt; for more information</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1.63里这个限制被放松了，显式泛型类型可以用 Turbofish 来指定了。不过 <code>impl Trait</code> 参数，尽管已经脱糖(desugare)成了泛型，因为还是不透明的所以无法通过 Turbofish 指定。</p><h2 id="完成了-non-lexical-lifetime-的生命周期检查器的迁移" tabindex="-1"><a class="header-anchor" href="#完成了-non-lexical-lifetime-的生命周期检查器的迁移"><span>完成了 Non-lexical-lifetime 的生命周期检查器的迁移</span></a></h2><p>1.63 的rustc，完全删除了之前的词法借用检查，完全启用了新的 NLL 借用检查器。这不会对编译结果有任何变化，但对编译器的借用错误检查有优化效果。</p><p>如果对NLL不了解，在本书 <a href="https://course.rs/basic/ownership/borrowing.html#NLL" target="_blank" rel="noopener noreferrer">引用与借用</a> 一章里有介绍。</p><p>或者看官方博客的介绍 <a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes" target="_blank" rel="noopener noreferrer">NLL</a></p><p>更详细内容可以看原博客 <a href="https://blog.rust-lang.org/2022/08/05/nll-by-default.html" target="_blank" rel="noopener noreferrer">blog</a></p>`,22)]))}const k=i(t,[["render",l],["__file","1.63.html.vue"]]),r=JSON.parse('{"path":"/appendix/rust-versions/1.63.html","title":"Rust 新版解读 | 1.63 | 重点: Scoped threads","lang":"zh-CN","frontmatter":{"description":"Rust 新版解读 | 1.63 | 重点: Scoped threads Rust 1.63 官方 release doc: Announcing Rust 1.63.0 | Rust Blog 通过 rustup 安装的同学可以使用以下命令升级到 1.63 版本: 区域线程 Scoped threads Rust 从 1.0 版本起，就可以使用 s...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/appendix/rust-versions/1.63.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"Rust 新版解读 | 1.63 | 重点: Scoped threads"}],["meta",{"property":"og:description","content":"Rust 新版解读 | 1.63 | 重点: Scoped threads Rust 1.63 官方 release doc: Announcing Rust 1.63.0 | Rust Blog 通过 rustup 安装的同学可以使用以下命令升级到 1.63 版本: 区域线程 Scoped threads Rust 从 1.0 版本起，就可以使用 s..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Rust 新版解读 | 1.63 | 重点: Scoped threads\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{},"readingTime":{"minutes":2.96,"words":888},"filePathRelative":"appendix/rust-versions/1.63.md","excerpt":"\\n<blockquote>\\n<p>Rust 1.63 官方 release doc: <a href=\\"https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Announcing Rust 1.63.0 | Rust Blog</a></p>\\n</blockquote>\\n<p>通过 <a href=\\"https://www.rust-lang.org/tools/install\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">rustup</a> 安装的同学可以使用以下命令升级到 1.63 版本:</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"appendix/rust-versions/1.63.md","value":{"title":"1.63","path":"appendix/rust-versions/1.63.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"appendix/rust-versions/1.63.md"}]}}}');export{k as comp,r as data};
