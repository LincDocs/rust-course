import{_ as r,e as t,k as a,o}from"./app-DxZopsRG.js";const n={};function s(l,e){return o(),t("div",null,e[0]||(e[0]=[a('<h1 id="features-示例" tabindex="-1"><a class="header-anchor" href="#features-示例"><span>Features 示例</span></a></h1><p>以下我们一起来看看一些来自真实世界的示例。</p><h3 id="最小化构建时间和文件大小" tabindex="-1"><a class="header-anchor" href="#最小化构建时间和文件大小"><span>最小化构建时间和文件大小</span></a></h3><p>如果一些包的部分特性不再启用，就可以减少该包占用的大小以及编译时间:</p><ul><li><a href="https://crates.io/crates/syn" target="_blank" rel="noopener noreferrer"><code>syn</code></a> 包可以用来解析 Rust 代码，由于它很受欢迎，大量的项目都在引用，因此它给出了<a href="https://docs.rs/syn/1.0.54/syn/#optional-features" target="_blank" rel="noopener noreferrer">非常清晰的文档</a>关于如何最小化使用它包含的 <code>features</code></li><li><a href="https://crates.io/crates/regex" target="_blank" rel="noopener noreferrer"><code>regex</code></a> 也有关于 features 的<a href="https://docs.rs/regex/1.4.2/regex/#crate-features" target="_blank" rel="noopener noreferrer">描述文档</a>，例如移除 Unicode 支持的 feature 可以降低最终生成可执行文件的大小</li><li><a href="https://crates.io/crates/winapi" target="_blank" rel="noopener noreferrer"><code>winapi</code></a> 拥有<a href="https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431" target="_blank" rel="noopener noreferrer">众多 features</a>，这些 <code>feature</code> 对用了各种 Windows API，你可以只引入代码中用到的 API 所对应的 feature.</li></ul><h3 id="行为扩展" tabindex="-1"><a class="header-anchor" href="#行为扩展"><span>行为扩展</span></a></h3><p><a href="https://crates.io/crates/serde_json" target="_blank" rel="noopener noreferrer"><code>serde_json</code></a> 拥有一个 <a href="https://github.com/serde-rs/json/blob/v1.0.60/Cargo.toml#L53-L56" target="_blank" rel="noopener noreferrer"><code>preserve_order</code> feature</a>，可以用于在序列化时保留 JSON 键值对的顺序。同时，该 feature 还会启用一个可选依赖 <a href="https://crates.io/crates/indexmap" target="_blank" rel="noopener noreferrer">indexmap</a>。</p><p>当这么做时，一定要小心不要破坏了 SemVer 的版本兼容性，也就是说：启用 feature 后，代码依然要能正常工作。</p><h3 id="no-std-支持" tabindex="-1"><a class="header-anchor" href="#no-std-支持"><span>no_std 支持</span></a></h3><p>一些包希望能同时支持 <a href="https://doc.rust-lang.org/stable/reference/names/preludes.html#the-no_std-attribute" target="_blank" rel="noopener noreferrer"><code>no_std</code></a> 和 <code>std</code> 环境，例如该包希望支持嵌入式系统或资源紧张的系统，且又希望能支持其它的平台，此时这种做法是非常有用的，因为标准库 <code>std</code> 会大幅增加编译出来的文件的大小，对于资源紧张的系统来说，<code>no_std</code> 才是最合适的。</p><p><a href="https://crates.io/crates/wasm-bindgen" target="_blank" rel="noopener noreferrer">wasm-bindgen</a> 定义了一个 <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L25" target="_blank" rel="noopener noreferrer">std feature</a>，它是<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L25" target="_blank" rel="noopener noreferrer">默认启用的</a>。首先，在库的顶部，它<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L8" target="_blank" rel="noopener noreferrer">无条件的启用了 <code>no_std</code> 属性</a>，它可以确保 <code>std</code> 和 <a href="https://doc.rust-lang.org/stable/std/prelude/index.html" target="_blank" rel="noopener noreferrer"><code>std prelude</code></a> 不会自动引入到作用域中来。其次，在不同的地方(<a href="https://doc.rust-lang.org/stable/std/prelude/index.html" target="_blank" rel="noopener noreferrer">示例 1</a>，<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L67-L75" target="_blank" rel="noopener noreferrer">示例 2</a>)，它通过 <code>#[cfg(feature = &quot;std&quot;)]</code> 启用 <code>std</code> feature 来添加 <code>std</code> 标准库支持。</p><h2 id="对依赖库的-features-进行再导出" tabindex="-1"><a class="header-anchor" href="#对依赖库的-features-进行再导出"><span>对依赖库的 features 进行再导出</span></a></h2><p>从依赖库再导出 features 在有些场景中会相当有用，这样用户就可以通过依赖包的 features 来控制功能而不是自己去手动定义。</p><p>例如 <a href="https://crates.io/crates/regex" target="_blank" rel="noopener noreferrer"><code>regex</code></a> 将 <a href="https://github.com/rust-lang/regex/blob/1.4.2/regex-syntax/Cargo.toml#L17-L32" target="_blank" rel="noopener noreferrer"><code>regex_syntax</code></a> 包的 features 进行了<a href="https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L65-L89" target="_blank" rel="noopener noreferrer">再导出</a>，这样 <code>regex</code> 的用户无需知道 <code>regex_syntax</code> 包，但是依然可以访问后者包含的 features。</p><h2 id="feature-优先级" tabindex="-1"><a class="header-anchor" href="#feature-优先级"><span>feature 优先级</span></a></h2><p>一些包可能会拥有彼此互斥的 features(无法共存，上一章节中有讲到)，其中一个办法就是为 feature 定义优先级，这样其中一个就会优于另一个被启用。</p><p>例如 <a href="https://crates.io/crates/log" target="_blank" rel="noopener noreferrer"><code>log</code></a> 包，它有<a href="https://github.com/rust-lang/log/blob/0.4.11/Cargo.toml#L29-L42" target="_blank" rel="noopener noreferrer">几个 features</a> 可以用于在编译期选择最大的<a href="https://docs.rs/log/0.4.11/log/#compile-time-filters" target="_blank" rel="noopener noreferrer">日志级别</a>，这里，它就使用了 <a href="https://crates.io/crates/cfg-if" target="_blank" rel="noopener noreferrer"><code>cfg-if</code></a> 的方式来<a href="https://github.com/rust-lang/log/blob/0.4.11/src/lib.rs#L1422-L1448" target="_blank" rel="noopener noreferrer">设置优先级</a>。一旦多个 <code>features</code> 被启用，那更高优先级的就会优先被启用。</p><h2 id="过程宏包" tabindex="-1"><a class="header-anchor" href="#过程宏包"><span>过程宏包</span></a></h2><p>一些包拥有过程宏，这些宏必须定义在一个独立的包中。但是不是所有的用户都需要过程宏的，因此也无需引入该包。</p><p>在这种情况下，将过程宏所在的包定义为可选依赖，是很不错的选择。这样做还有一个好处：有时过程宏的版本必须要跟父包进行同步，但是我们又不希望所有的用户都进行同步。</p><p>其中一个例子就是 <a href="https://crates.io/crates/serde" target="_blank" rel="noopener noreferrer">serde</a> ，它有一个 <a href="https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L34-L35" target="_blank" rel="noopener noreferrer">derive</a> feature 可以启用 <a href="https://crates.io/crates/serde_derive" target="_blank" rel="noopener noreferrer">serde_derive</a> 过程宏。由于 <code>serde_derive</code> 包跟 <code>serde</code> 的关系非常紧密，因此它使用了<a href="https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L17" target="_blank" rel="noopener noreferrer">版本相同的需求</a>来保证两者的版本同步性。</p><h2 id="只能用于-nightly-的-feature" tabindex="-1"><a class="header-anchor" href="#只能用于-nightly-的-feature"><span>只能用于 nightly 的 feature</span></a></h2><p>Rust 有些实验性的 API 或语言特性只能在 nightly 版本下使用，但某些使用了这些 API 的包并不想强制他们的用户也使用 <code>nightly</code> 版本，因此他们会通过 feature 的方式来控制。</p><p>若用户希望使用这些 API 时，需要启用相应的 feature ，而这些 feature 只能在 nightly 下使用。若用户不需要使用这些 API，就无需开启 相应的 feature，自然也不需要使用 nightly 版本。</p><p>例如 <a href="https://crates.io/crates/rand" target="_blank" rel="noopener noreferrer"><code>rand</code></a> 包有一个 <a href="https://github.com/rust-random/rand/blob/0.7.3/Cargo.toml#L40" target="_blank" rel="noopener noreferrer">simd_support</a> feature 就只能在 nightly 下使用，若我们不使用该 feature，则在 stable 下依然可以使用 <code>rand</code>。</p><h2 id="实验性-feature" tabindex="-1"><a class="header-anchor" href="#实验性-feature"><span>实验性 feature</span></a></h2><p>有一些包会提前将一些实验性的 API 放出去，既然是实验性的，自然无法保证其稳定性。在这种情况下，通常会在文档中将相应的 features 标记为实验性，意味着它们在未来可能会发生大的改变(甚至 minor 版本都可能发生)。</p><p>其中一个例子是 <a href="https://crates.io/crates/async-std" target="_blank" rel="noopener noreferrer">async-std</a> 包，它拥有一个 <a href="https://github.com/async-rs/async-std/blob/v1.8.0/Cargo.toml#L38-L42" target="_blank" rel="noopener noreferrer">unstable feature</a>，用来<a href="https://github.com/async-rs/async-std/blob/v1.8.0/src/macros.rs#L46" target="_blank" rel="noopener noreferrer">标记一些新的 API</a>，表示人们已经可以选择性的使用但是还没有准备好去依赖它。</p>',28)]))}const p=r(n,[["render",s],["__file","examples.html.vue"]]),d=JSON.parse('{"path":"/cargo/reference/features/examples.html","title":"Features 示例","lang":"zh-CN","frontmatter":{"description":"Features 示例 以下我们一起来看看一些来自真实世界的示例。 最小化构建时间和文件大小 如果一些包的部分特性不再启用，就可以减少该包占用的大小以及编译时间: syn 包可以用来解析 Rust 代码，由于它很受欢迎，大量的项目都在引用，因此它给出了非常清晰的文档关于如何最小化使用它包含的 features regex 也有关于 features 的...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/cargo/reference/features/examples.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"Features 示例"}],["meta",{"property":"og:description","content":"Features 示例 以下我们一起来看看一些来自真实世界的示例。 最小化构建时间和文件大小 如果一些包的部分特性不再启用，就可以减少该包占用的大小以及编译时间: syn 包可以用来解析 Rust 代码，由于它很受欢迎，大量的项目都在引用，因此它给出了非常清晰的文档关于如何最小化使用它包含的 features regex 也有关于 features 的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Features 示例\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{},"readingTime":{"minutes":4.37,"words":1311},"filePathRelative":"cargo/reference/features/examples.md","excerpt":"\\n<p>以下我们一起来看看一些来自真实世界的示例。</p>\\n<h3>最小化构建时间和文件大小</h3>\\n<p>如果一些包的部分特性不再启用，就可以减少该包占用的大小以及编译时间:</p>\\n<ul>\\n<li><a href=\\"https://crates.io/crates/syn\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>syn</code></a> 包可以用来解析 Rust 代码，由于它很受欢迎，大量的项目都在引用，因此它给出了<a href=\\"https://docs.rs/syn/1.0.54/syn/#optional-features\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">非常清晰的文档</a>关于如何最小化使用它包含的 <code>features</code></li>\\n<li><a href=\\"https://crates.io/crates/regex\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>regex</code></a> 也有关于 features 的<a href=\\"https://docs.rs/regex/1.4.2/regex/#crate-features\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">描述文档</a>，例如移除 Unicode 支持的 feature 可以降低最终生成可执行文件的大小</li>\\n<li><a href=\\"https://crates.io/crates/winapi\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>winapi</code></a> 拥有<a href=\\"https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">众多 features</a>，这些 <code>feature</code> 对用了各种 Windows API，你可以只引入代码中用到的 API 所对应的 feature.</li>\\n</ul>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"cargo/reference/features/examples.md","value":{"title":"examples","path":"cargo/reference/features/examples.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"cargo/reference/features/examples.md"}]}}}');export{p as comp,d as data};
