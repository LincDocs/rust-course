import{_ as t,e as s,k as i,o as r}from"./app-DEcddxss.js";const a={};function n(l,e){return r(),s("div",null,e[0]||(e[0]=[i(`<h1 id="命名规范" tabindex="-1"><a class="header-anchor" href="#命名规范"><span>命名规范</span></a></h1><p>基本的 Rust 命名规范在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md" target="_blank" rel="noopener noreferrer">RFC 430</a> 中有描述。</p><p>通常，对于 <strong>type-level</strong> 的构造 Rust 倾向于使用<strong>驼峰命名法</strong>，而对于 <strong>value-level</strong> 的构造使用<strong>蛇形命名法</strong>。详情如下：</p><table><thead><tr><th>条目</th><th>惯例</th></tr></thead><tbody><tr><td>包 Crates</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/29" target="_blank" rel="noopener noreferrer">unclear</a></td></tr><tr><td>模块 Modules</td><td><code>snake_case</code></td></tr><tr><td>类型 Types</td><td><code>UpperCamelCase</code></td></tr><tr><td>特征 Traits</td><td><code>UpperCamelCase</code></td></tr><tr><td>枚举 Enumerations</td><td><code>UpperCamelCase</code></td></tr><tr><td>结构体 Structs</td><td><code>UpperCamelCase</code></td></tr><tr><td>函数 Functions</td><td><code>snake_case</code></td></tr><tr><td>方法 Methods</td><td><code>snake_case</code></td></tr><tr><td>通用构造器 General constructors</td><td><code>new</code> or <code>with_more_details</code></td></tr><tr><td>转换构造器 Conversion constructors</td><td><code>from_some_other_type</code></td></tr><tr><td>宏 Macros</td><td><code>snake_case!</code></td></tr><tr><td>局部变量 Local variables</td><td><code>snake_case</code></td></tr><tr><td>静态类型 Statics</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr><tr><td>常量 Constants</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr><tr><td>类型参数 Type parameters</td><td><code>UpperCamelCase</code>，通常使用一个大写字母: <code>T</code></td></tr><tr><td>生命周期 Lifetimes</td><td>通常使用小写字母: <code>&#39;a</code>，<code>&#39;de</code>，<code>&#39;src</code></td></tr><tr><td>Features</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/101" target="_blank" rel="noopener noreferrer">unclear</a> but see <a href="#c-feature">C-FEATURE</a></td></tr></tbody></table><p>对于<strong>驼峰命名法</strong>，复合词的缩略形式我们认为是一个单独的词语，所以<strong>只对首字母进行大写</strong>：使用 <code>Uuid</code> 而不是 <s><code>UUID</code></s>，<code>Usize</code> 而不是 <s><code>USize</code></s>，<code>Stdin</code> 而不是 <s><code>StdIn</code></s>。</p><p>对于<strong>蛇形命名法</strong>，缩略词用全小写：<code>is_xid_start</code>。</p><p>对于<strong>蛇形命名法</strong>（包括全大写的 <code>SCREAMING_SNAKE_CASE</code>），除了最后一部分，其它部分的词语都不能由单个字母组成：<br><code>btree_map</code> 而不是 <s><code>b_tree_map</code></s>，<code>PI_2</code> 而不是 <s><code>PI2</code></s>.</p><p>包名<strong>不应该</strong>使用 <code>-rs</code> 或者 <code>-rust</code> 作为后缀，因为每一个包都是 Rust 写的，因此这种多余的注释其实没有任何意义。</p><h2 id="特征命名" tabindex="-1"><a class="header-anchor" href="#特征命名"><span>特征命名</span></a></h2><p>特征的名称应该使用动词，而不是形容词或者名词，例如 <code>Print</code> 和 <code>Draw</code> 明显好于 <code>Printable</code> 和 <code>Drawable</code>。</p><h2 id="类型转换要遵守-as-to-into-命名惯例-c-conv" tabindex="-1"><a class="header-anchor" href="#类型转换要遵守-as-to-into-命名惯例-c-conv"><span>类型转换要遵守 <code>as_</code>，<code>to_</code>，<code>into_</code> 命名惯例(C-CONV)</span></a></h2><p>类型转换应该通过方法调用的方式实现，其中的前缀规则如下：</p><table><thead><tr><th>方法前缀</th><th>性能开销</th><th>所有权改变</th></tr></thead><tbody><tr><td><code>as_</code></td><td>Free</td><td>borrowed -&gt; borrowed</td></tr><tr><td><code>to_</code></td><td>Expensive</td><td>borrowed -&gt; borrowed<br>borrowed -&gt; owned (non-Copy types)<br>owned -&gt; owned (Copy types)</td></tr><tr><td><code>into_</code></td><td>Variable</td><td>owned -&gt; owned (non-Copy types)</td></tr></tbody></table><p>例如：</p><ul><li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes" target="_blank" rel="noopener noreferrer"><code>str::as_bytes()</code></a> 把 <code>str</code> 变成 UTF-8 字节数组，性能开销是 0。输入是一个借用的 <code>&amp;str</code>，输出也是一个借用的 <code>&amp;str</code></li><li><a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.to_str" target="_blank" rel="noopener noreferrer"><code>Path::to_str</code></a> 会执行一次昂贵的 UTF-8 字节数组检查，输入和输出都是借用的。对于这种情况，如果把方法命名为 <code>as_str</code> 是不正确的，因为这个方法的开销还挺大</li><li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase" target="_blank" rel="noopener noreferrer"><code>str::to_lowercase()</code></a> 在调用过程中会遍历字符串的字符，且可能会分配新的内存对象。输入是一个借用的 <code>str</code>，输出是一个有独立所有权的 <code>String</code></li><li><a href="https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes" target="_blank" rel="noopener noreferrer"><code>String::into_bytes()</code></a> 返回 <code>String</code> 底层的 <code>Vec&lt;u8&gt;</code> 数组，转换本身是零消耗的。该方法获取 <code>String</code> 的所有权，然后返回一个新的有独立所有权的 <code>Vec&lt;u8&gt;</code></li></ul><p>当一个单独的值被某个类型所包装时，访问该类型的内部值应通过 <code>into_inner()</code> 方法来访问。例如将一个缓冲区值包装为 <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner" target="_blank" rel="noopener noreferrer"><code>BufReader</code></a> 类型，还有 <a href="https://starry-network.github.io/starry_node/flate2/write/struct.GzDecoder.html#method.into_inner" target="_blank" rel="noopener noreferrer"><code>GzDecoder</code></a>、<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner" target="_blank" rel="noopener noreferrer"><code>AtomicBool</code></a> 等，都是这种类型。</p><p>如果 <code>mut</code> 限定符在返回类型中出现，那么在命名上也<strong>应该</strong>体现出来。例如，<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice" target="_blank" rel="noopener noreferrer"><code>Vec::as_mut_slice</code></a> 就说明它返回了一个 <code>mut</code> 切片，在这种情况下 <code>as_mut_slice</code> 比 <code>as_slice_mut</code> 更适合。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 返回类型是一个 \`mut\` 切片</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> as_mut_slice</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="标准库中的一些例子" tabindex="-1"><a class="header-anchor" href="#标准库中的一些例子"><span>标准库中的一些例子</span></a></h3><ul><li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref" target="_blank" rel="noopener noreferrer"><code>Result::as_ref</code></a></li><li><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr" target="_blank" rel="noopener noreferrer"><code>RefCell::as_ptr</code></a></li><li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec" target="_blank" rel="noopener noreferrer"><code>slice::to_vec</code></a></li><li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter" target="_blank" rel="noopener noreferrer"><code>Option::into_iter</code></a></li></ul><h2 id="读访问器-getter-的名称遵循-rust-的命名规范-c-getter" tabindex="-1"><a class="header-anchor" href="#读访问器-getter-的名称遵循-rust-的命名规范-c-getter"><span>读访问器(Getter)的名称遵循 Rust 的命名规范(C-GETTER)</span></a></h2><p>除了少数例外，在 Rust代码中 <code>get</code> 前缀不用于 Getter。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">pub</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> S</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    first</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">First</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    second</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Second</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">impl</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> S</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 而不是 get_first</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    pub</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> first</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; &amp;</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">First</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        &amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.first</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 而不是 get_first_mut，get_mut_first，or mut_first</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    pub</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> first_mut</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> First</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.first</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至于上文提到的少数例外，如下：<strong>当有且仅有一个值</strong>能被 Getter 所获取时，才使用 <code>get</code> 前缀。例如，<a href="https://doc.rust-lang.org/std/cell/struct.Cell.html#method.get" target="_blank" rel="noopener noreferrer"><code>Cell::get</code></a> 能直接访问到 <code>Cell</code> 中的内容。</p><p>有些 Getter 会在过程中执行运行时检查，那么我们就可以考虑添加 <code>_unchecked</code> Getter 函数，这个函数虽然不安全，但是往往具有更高的性能。<br> 典型的例子如下：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Option</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&amp;</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get_mut</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Option</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> V</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unsafe</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get_unchecked</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; &amp;</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unsafe</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get_unchecked_mut</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> V</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="标准库示例" tabindex="-1"><a class="header-anchor" href="#标准库示例"><span>标准库示例</span></a></h3><ul><li><a href="https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut" target="_blank" rel="noopener noreferrer"><code>std::io::Cursor::get_mut</code></a></li><li><a href="https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut" target="_blank" rel="noopener noreferrer"><code>std::ptr::Unique::get_mut</code></a></li><li><a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut" target="_blank" rel="noopener noreferrer"><code>std::sync::PoisonError::get_mut</code></a></li><li><a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut" target="_blank" rel="noopener noreferrer"><code>std::sync::atomic::AtomicBool::get_mut</code></a></li><li><a href="https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut" target="_blank" rel="noopener noreferrer"><code>std::collections::hash_map::OccupiedEntry::get_mut</code></a></li><li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked" target="_blank" rel="noopener noreferrer"><code>&lt;[T]&gt;::get_unchecked</code></a></li></ul><h2 id="一个集合上的方法-如果返回迭代器-需遵循命名规则-iter-iter-mut-into-iter-c-iter" tabindex="-1"><a class="header-anchor" href="#一个集合上的方法-如果返回迭代器-需遵循命名规则-iter-iter-mut-into-iter-c-iter"><span>一个集合上的方法，如果返回迭代器，需遵循命名规则：<code>iter</code>，<code>iter_mut</code>，<code>into_iter</code> (C-ITER)</span></a></h2><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> iter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Iter</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">             // Iter implements Iterator&lt;Item = &amp;U&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> iter_mut</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">IterMut</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // IterMut implements Iterator&lt;Item = &amp;mut U&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> into_iter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">IntoIter</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     // IntoIter implements Iterator&lt;Item = U&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的规则适用于同构性的数据集合。与之相反，<code>str</code> 类型是一个 UTF-8 字节数组切片，与同构性集合有一点微妙的差别，它可以认为是字节集合，也可以认为是字符集合，因此它提供了 <a href="https://doc.rust-lang.org/std/primitive.str.html#method.bytes" target="_blank" rel="noopener noreferrer"><code>str::bytes</code></a> 去遍历字节，还有 <a href="https://doc.rust-lang.org/std/primitive.str.html#method.chars" target="_blank" rel="noopener noreferrer"><code>str::chars</code></a> 去遍历字符，而并没有直接定义 <code>iter</code> 等方法。</p><p>上述规则只适用于方法，并不适用于函数。例如 <code>url</code> 包的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html" target="_blank" rel="noopener noreferrer"><code>percent_encode</code></a> 函数返回一个迭代器用于遍历百分比编码（<a href="https://en.wikipedia.org/wiki/Percent-encoding" target="_blank" rel="noopener noreferrer">Percent encoding</a>）的字符串片段. 在这种情况下，使用 <code>iter</code>/<code>iter_mut</code>/<code>into_iter</code> 诸如此类的函数命名无法表达任何具体的含义。</p><h3 id="标准库示例-1" tabindex="-1"><a class="header-anchor" href="#标准库示例-1"><span>标准库示例</span></a></h3><ul><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter" target="_blank" rel="noopener noreferrer"><code>Vec::iter</code></a></li><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut" target="_blank" rel="noopener noreferrer"><code>Vec::iter_mut</code></a></li><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter" target="_blank" rel="noopener noreferrer"><code>Vec::into_iter</code></a></li><li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter" target="_blank" rel="noopener noreferrer"><code>BTreeMap::iter</code></a></li><li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut" target="_blank" rel="noopener noreferrer"><code>BTreeMap::iter_mut</code></a></li></ul><h2 id="迭代器的类型应该与产生它的方法名相匹配-c-iter-ty" tabindex="-1"><a class="header-anchor" href="#迭代器的类型应该与产生它的方法名相匹配-c-iter-ty"><span>迭代器的类型应该与产生它的方法名相匹配(C-ITER-TY)</span></a></h2><p>例如形如 <code>into_iter()</code> 的方法应该返回一个 <code>IntoIter</code> 类型，与之相似，其它任何返回迭代器的方法也应该遵循这种命名惯例。</p><p>上述规则主要应用于方法，但是经常对于函数也适用。例如上文提到的 <code>url</code> 包中的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html" target="_blank" rel="noopener noreferrer"><code>percent_encode</code></a> 函数，返回了一个 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/struct.PercentEncode.html" target="_blank" rel="noopener noreferrer"><code>PercentEncode</code></a> 类型。</p><p>特别是，当这些类型跟包名前缀一起使用时，将具备非常清晰的含义，例如 <a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html" target="_blank" rel="noopener noreferrer"><code>vec::IntoIter</code></a>。</p><h3 id="标准库示例-2" tabindex="-1"><a class="header-anchor" href="#标准库示例-2"><span>标准库示例</span></a></h3><ul><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter" target="_blank" rel="noopener noreferrer"><code>Vec::iter</code></a> returns <a href="https://doc.rust-lang.org/std/slice/struct.Iter.html" target="_blank" rel="noopener noreferrer"><code>Iter</code></a></li><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut" target="_blank" rel="noopener noreferrer"><code>Vec::iter_mut</code></a> returns <a href="https://doc.rust-lang.org/std/slice/struct.IterMut.html" target="_blank" rel="noopener noreferrer"><code>IterMut</code></a></li><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter" target="_blank" rel="noopener noreferrer"><code>Vec::into_iter</code></a> returns <a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html" target="_blank" rel="noopener noreferrer"><code>IntoIter</code></a></li><li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys" target="_blank" rel="noopener noreferrer"><code>BTreeMap::keys</code></a> returns <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html" target="_blank" rel="noopener noreferrer"><code>Keys</code></a></li><li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values" target="_blank" rel="noopener noreferrer"><code>BTreeMap::values</code></a> returns <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html" target="_blank" rel="noopener noreferrer"><code>Values</code></a></li></ul><p><a id="c-feature"></a></p><h2 id="cargo-feature-的名称不应该包含占位词-c-feature" tabindex="-1"><a class="header-anchor" href="#cargo-feature-的名称不应该包含占位词-c-feature"><span>Cargo Feature 的名称不应该包含占位词(C-FEATURE)</span></a></h2><p>不要在 <a href="http://doc.crates.io/manifest.html#the-features-section" target="_blank" rel="noopener noreferrer">Cargo feature</a> 中包含无法传达任何意义的词，例如 <code>use-abc</code> 或 <code>with-abc</code>，直接命名为 <code>abc</code> 即可。</p><p>一个典型的例子就是：一个包对标准库有可选性的依赖。标准的写法如下：</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" data-title="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 在 Cargo.toml 中</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">features</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">default</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;std&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = []</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在我们自定义的 lib.rs 中</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">#![cfg_attr(not(feature </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;std&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">), no_std)]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了 <code>std</code> 之外，不要使用任何 <code>ust-std</code> 或者 <code>with-std</code> 等自以为很有创造性的名称。</p><h2 id="命名要使用一致性的词序-c-word-order" tabindex="-1"><a class="header-anchor" href="#命名要使用一致性的词序-c-word-order"><span>命名要使用一致性的词序(C-WORD-ORDER)</span></a></h2><p>这是一些标准库中的错误类型:</p><ul><li><a href="https://doc.rust-lang.org/std/env/struct.JoinPathsError.html" target="_blank" rel="noopener noreferrer"><code>JoinPathsError</code></a></li><li><a href="https://doc.rust-lang.org/std/str/struct.ParseBoolError.html" target="_blank" rel="noopener noreferrer"><code>ParseBoolError</code></a></li><li><a href="https://doc.rust-lang.org/std/char/struct.ParseCharError.html" target="_blank" rel="noopener noreferrer"><code>ParseCharError</code></a></li><li><a href="https://doc.rust-lang.org/std/num/struct.ParseFloatError.html" target="_blank" rel="noopener noreferrer"><code>ParseFloatError</code></a></li><li><a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html" target="_blank" rel="noopener noreferrer"><code>ParseIntError</code></a></li><li><a href="https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html" target="_blank" rel="noopener noreferrer"><code>RecvTimeoutError</code></a></li><li><a href="https://doc.rust-lang.org/std/path/struct.StripPrefixError.html" target="_blank" rel="noopener noreferrer"><code>StripPrefixError</code></a></li></ul><p>它们都使用了 <code>谓语-宾语-错误</code> 的词序，如果我们想要表达一个网络地址无法分析的错误，由于词序一致性的原则，命名应该如下 <code>ParseAddrError</code>，而不是 <code>AddrParseError</code>。</p><p>词序和个人习惯有很大关系，想要注意的是，你可以选择合适的词序，但是要在包的范畴内保持一致性，就如标准库中的包一样。</p>`,52)]))}const o=t(a,[["render",n],["__file","naming.html.vue"]]),h=JSON.parse('{"path":"/practice/naming.html","title":"命名规范","lang":"zh-CN","frontmatter":{"description":"命名规范 基本的 Rust 命名规范在 RFC 430 中有描述。 通常，对于 type-level 的构造 Rust 倾向于使用驼峰命名法，而对于 value-level 的构造使用蛇形命名法。详情如下： 对于驼峰命名法，复合词的缩略形式我们认为是一个单独的词语，所以只对首字母进行大写：使用 Uuid 而不是 ，Usize 而不是 ，Stdin 而不...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/practice/naming.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"命名规范"}],["meta",{"property":"og:description","content":"命名规范 基本的 Rust 命名规范在 RFC 430 中有描述。 通常，对于 type-level 的构造 Rust 倾向于使用驼峰命名法，而对于 value-level 的构造使用蛇形命名法。详情如下： 对于驼峰命名法，复合词的缩略形式我们认为是一个单独的词语，所以只对首字母进行大写：使用 Uuid 而不是 ，Usize 而不是 ，Stdin 而不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"命名规范\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{},"readingTime":{"minutes":6.78,"words":2033},"filePathRelative":"practice/naming.md","excerpt":"\\n<p>基本的 Rust 命名规范在 <a href=\\"https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">RFC 430</a> 中有描述。</p>\\n<p>通常，对于 <strong>type-level</strong> 的构造 Rust 倾向于使用<strong>驼峰命名法</strong>，而对于 <strong>value-level</strong> 的构造使用<strong>蛇形命名法</strong>。详情如下：</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"practice/naming.md","value":{"title":"naming","path":"practice/naming.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"practice/naming.md"}]}}}');export{o as comp,h as data};
