import{_ as s,e,k as a,o as r}from"./app-DxZopsRG.js";const n={};function l(t,i){return r(),e("div",null,i[0]||(i[0]=[a(`<h1 id="构建脚本-build-scripts" tabindex="-1"><a class="header-anchor" href="#构建脚本-build-scripts"><span>构建脚本( Build Scripts)</span></a></h1><p>一些项目希望编译第三方的非 Rust 代码，例如 C 依赖库；一些希望链接本地或者基于源码构建的 C 依赖库；还有一些项目需要功能性的工具，例如在构建之间执行一些代码生成的工作等。</p><p>对于这些目标，社区已经提供了一些工具来很好的解决，Cargo 并不想替代它们，但是为了给用户带来一些便利，Cargo 提供了自定义构建脚本的方式，来帮助用户更好的解决类似的问题。</p><h2 id="build-rs" tabindex="-1"><a class="header-anchor" href="#build-rs"><span>build.rs</span></a></h2><p>若要创建构建脚本，我们只需在项目的根目录下添加一个 <code>build.rs</code> 文件即可。这样一来， Cargo 就会先编译和执行该构建脚本，然后再去构建整个项目。</p><p>以下是一个非常简单的脚本示例:</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 以下代码告诉 Cargo ，一旦指定的文件 \`src/hello.c\` 发生了改变，就重新运行当前的构建脚本</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;cargo:rerun-if-changed=src/hello.c&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 使用 \`cc\` 来构建一个 C 文件，然后进行静态链接</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    cc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Build</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">new</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">file</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;src/hello.c&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">compile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于构建脚本的一些使用场景如下：</p><ul><li>构建 C 依赖库</li><li>在操作系统中寻找指定的 C 依赖库</li><li>根据某个说明描述文件生成一个 Rust 模块</li><li>执行一些平台相关的配置</li></ul><p>下面的部分我们一起来看看构建脚本具体是如何工作的，然后在<a href="https://course.rs/cargo/reference/build-script/examples.html" target="_blank" rel="noopener noreferrer">下个章节</a>中还提供了一些关于如何编写构建脚本的示例。</p><blockquote><p>Note: <a href="https://course.rs/cargo/reference/manifest.html#build" target="_blank" rel="noopener noreferrer"><code>package.build</code></a> 可以用于改变构建脚本的名称，或者直接禁用该功能</p></blockquote><h2 id="构建脚本的生命周期" tabindex="-1"><a class="header-anchor" href="#构建脚本的生命周期"><span>构建脚本的生命周期</span></a></h2><p>在项目被构建之前，Cargo 会将构建脚本编译成一个可执行文件，然后运行该文件并执行相应的任务。</p><p>在运行的过程中，<strong>脚本可以使用之前 <code>println</code> 的方式跟 Cargo 进行通信</strong>：通信内容是以 <code>cargo:</code> 开头的格式化字符串。</p><p>需要注意的是，Cargo 也不是每次都会重新编译构建脚本，只有当脚本的内容或依赖发生变化时才会。默认情况下，任何文件变化都会触发重新编译，如果你希望对其进行定制，可以使用 <code>rerun-if</code>命令，后文会讲。</p><p>在构建脚本成功执行后，我们的项目就会开始进行编译。如果构建脚本的运行过程中发生错误，脚本应该通过返回一个非 0 码来立刻退出，在这种情况下，构建脚本的输出会被打印到终端中。</p><h2 id="构建脚本的输入" tabindex="-1"><a class="header-anchor" href="#构建脚本的输入"><span>构建脚本的输入</span></a></h2><p>我们可以通过<a href="https://doc.rust-lang.org/stable/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts" target="_blank" rel="noopener noreferrer">环境变量</a>的方式给构建脚本提供一些输入值，除此之外，构建脚本所在的当前目录也可以。</p><h2 id="构建脚本的输出" tabindex="-1"><a class="header-anchor" href="#构建脚本的输出"><span>构建脚本的输出</span></a></h2><p>构建脚本如果会产出文件，那么这些文件需要放在统一的目录中，该目录可以通过 <a href="https://doc.rust-lang.org/stable/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts" target="_blank" rel="noopener noreferrer"><code>OUT_DIR</code> 环境变量</a>来指定，<strong>构建脚本不应该修改该目录之外的任何文件！</strong></p><p>在之前提到过，构建脚本可以通过 <code>println!</code> 输出内容跟 Cargo 进行通信：Cargo 会将每一行带有 <code>cargo:</code> 前缀的输出解析为一条指令，其它的输出内容会自动被忽略。</p><p>通过 <code>println!</code> 输出的内容在构建过程中默认是隐藏的，如果大家想要在终端中看到这些内容，你可以使用 <code>-vv</code> 来调用，以下 <code>build.rs</code> ：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello, build.rs&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将输出:</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cargo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -vv</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[study_cargo 0.1.0] hello, build.rs</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>构建脚本打印到标准输出 <code>stdout</code> 的所有内容将保存在文件 <code>target/debug/build/&lt;pkg&gt;/output</code> 中 (具体的位置可能取决于你的配置)，<code>stderr</code> 的输出内容也将保存在同一个目录中。</p><p>以下是 Cargo 能识别的通信指令以及简介，如果大家希望深入了解每个命令，可以点击具体的链接查看官方文档的说明。</p><ul><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rerun-if-changed" target="_blank" rel="noopener noreferrer"><code>cargo:rerun-if-changed=PATH</code></a> — 当指定路径的文件发生变化时，Cargo 会重新运行脚本</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rerun-if-env-changed" target="_blank" rel="noopener noreferrer"><code>cargo:rerun-if-env-changed=VAR</code></a> — 当指定的环境变量发生变化时，Cargo 会重新运行脚本</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-link-arg" target="_blank" rel="noopener noreferrer"><code>cargo:rustc-link-arg=FLAG</code></a> – 将自定义的 flags 传给 linker，用于后续的基准性能测试 benchmark、 可执行文件 binary,、<code>cdylib</code> 包、示例和测试</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-link-arg-bin" target="_blank" rel="noopener noreferrer"><code>cargo:rustc-link-arg-bin=BIN=FLAG</code></a> – 自定义的 flags 传给 linker，用于可执行文件 <code>BIN</code></li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-link-arg-bins" target="_blank" rel="noopener noreferrer"><code>cargo:rustc-link-arg-bins=FLAG</code></a> – 自定义的 flags 传给 linker，用于可执行文件</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-link-arg-tests" target="_blank" rel="noopener noreferrer"><code>cargo:rustc-link-arg-tests=FLAG</code></a> – 自定义的 flags 传给 linker，用于测试</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-link-arg-examples" target="_blank" rel="noopener noreferrer"><code>cargo:rustc-link-arg-examples=FLAG</code></a> – 自定义的 flags 传给 linker，用于示例</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-link-arg-benches" target="_blank" rel="noopener noreferrer"><code>cargo:rustc-link-arg-benches=FLAG</code></a> – 自定义的 flags 传给 linker，用于基准性能测试 benchmark</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-cdylib-link-arg" target="_blank" rel="noopener noreferrer"><code>cargo:rustc-cdylib-link-arg=FLAG</code></a> — 自定义的 flags 传给 linker，用于 <code>cdylib</code> 包</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-link-lib" target="_blank" rel="noopener noreferrer"><code>cargo:rustc-link-lib=[KIND=]NAME</code></a> — 告知 Cargo 通过 <code>-l</code> 去链接一个指定的库，往往用于链接一个本地库，通过 FFI</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-link-search" target="_blank" rel="noopener noreferrer"><code>cargo:rustc-link-search=[KIND=]PATH</code></a> — 告知 Cargo 通过 <code>-L</code> 将一个目录添加到依赖库的搜索路径中</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-flags" target="_blank" rel="noopener noreferrer"><code>cargo:rustc-flags=FLAGS</code></a> — 将特定的 flags 传给编译器</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-cfg" target="_blank" rel="noopener noreferrer"><code>cargo:rustc-cfg=KEY[=&quot;VALUE&quot;]</code></a> — 开启编译时 <code>cfg</code> 设置</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-env" target="_blank" rel="noopener noreferrer"><code>cargo:rustc-env=VAR=VALUE</code></a> — 设置一个环境变量</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#cargo-warning" target="_blank" rel="noopener noreferrer"><code>cargo:warning=MESSAGE</code></a> — 在终端打印一条 warning 信息</li><li><a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#the-links-manifest-key" target="_blank" rel="noopener noreferrer"><code>cargo:KEY=VALUE</code></a> — <code>links</code> 脚本使用的元数据</li></ul><h2 id="构建脚本的依赖" tabindex="-1"><a class="header-anchor" href="#构建脚本的依赖"><span>构建脚本的依赖</span></a></h2><p>构建脚本也可以引入其它基于 Cargo 的依赖包，只需要在 <code>Cargo.toml</code> 中添加或修改以下内容:</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" data-title="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">build-dependencies</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">cc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;1.0.46&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>需要这么配置的原因在于构建脚本无法使用通过 <code>[dependencies]</code> 或 <code>[dev-dependencies]</code> 引入的依赖包，因为构建脚本的编译运行过程跟项目本身的编译过程是分离的的，且前者先于后者发生。同样的，我们项目也无法使用 <code>[build-dependencies]</code> 中的依赖包。</p><p><strong>大家在引入依赖的时候，需要仔细考虑它会给编译时间、开源协议和维护性等方面带来什么样的影响</strong>。如果你在 <code>[build-dependencies]</code> 和 <code>[dependencies]</code> 引入了同样的包，这种情况下 Cargo 也许会对依赖进行复用，也许不会，例如在交叉编译时，如果不会，那编译速度自然会受到不小的影响。</p><h2 id="links" tabindex="-1"><a class="header-anchor" href="#links"><span>links</span></a></h2><p>在 <code>Cargo.toml</code> 中可以配置 <code>package.links</code> 选项，它的目的是告诉 Cargo 当前项目所链接的本地库，同时提供了一种方式可以在项目构建脚本之间传递元信息。</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" data-title="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">package</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># ...</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">links</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;foo&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上配置表明项目链接到一个 <code>libfoo</code> 本地库，当使用 <code>links</code> 时，项目必须拥有一个构建脚本，并且该脚本需要使用 <a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-link-lib" target="_blank" rel="noopener noreferrer"><code>rustc-link-lib</code></a> 指令来链接目标库。</p><p>Cargo 要求一个本地库最多只能被一个项目所链接，换而言之，你无法让两个项目链接到同一个本地库，但是有一种方法可以降低这种限制，感兴趣的同学可以看看<a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#-sys-packages" target="_blank" rel="noopener noreferrer">官方文档</a>。</p><p>假设 A 项目的构建脚本生成任意数量的 kv 形式的元数据，那这些元数据将传递给 A 用作依赖包的项目的构建脚本。例如，如果包 <code>bar</code> 依赖于 <code>foo</code>，当 <code>foo</code> 生成 <code>key=value</code> 形式的构建脚本元数据时，那么 <code>bar</code> 的构建脚本就可以通过环境变量的形式使用该元数据：<code>DEP_FOO_KEY=value</code>。</p><p>需要注意的是，该元数据只能传给直接相关者，对于间接的，例如依赖的依赖，就无能为力了。</p><h2 id="覆盖构建脚本" tabindex="-1"><a class="header-anchor" href="#覆盖构建脚本"><span>覆盖构建脚本</span></a></h2><p>当 <code>Cargo.toml</code> 设置了 <code>links</code> 时， Cargo 就允许我们使用自定义库对现有的构建脚本进行覆盖。在 <a href="https://course.rs/cargo/reference/configuration.html" target="_blank" rel="noopener noreferrer">Cargo 使用的配置文件</a>中添加以下内容：</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" data-title="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">target</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">x86_64-unknown-linux-gnu</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rustc-link-lib</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;foo&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rustc-link-search</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;/path/to/foo&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rustc-flags</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;-L /some/path&quot;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rustc-cfg</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;key=&quot;value&quot;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rustc-env</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = {</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;value&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rustc-cdylib-link-arg</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;…&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">metadata_key1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;value&quot;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">metadata_key2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;value&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>增加这个配置后，在未来，一旦我们的某个项目声明了它链接到 <code>foo</code> ，那项目的构建脚本将不会被编译和运行，替代的是这里的配置将被使用。</p><p><code>warning</code>, <code>rerun-if-changed</code> 和 <code>rerun-if-env-changed</code> 这三个 key 在这里不应该被使用，就算用了也会被忽略。</p>`,45)]))}const h=s(n,[["render",l],["__file","intro.html.vue"]]),d=JSON.parse('{"path":"/cargo/reference/build-script/intro.html","title":"构建脚本( Build Scripts)","lang":"zh-CN","frontmatter":{"description":"构建脚本( Build Scripts) 一些项目希望编译第三方的非 Rust 代码，例如 C 依赖库；一些希望链接本地或者基于源码构建的 C 依赖库；还有一些项目需要功能性的工具，例如在构建之间执行一些代码生成的工作等。 对于这些目标，社区已经提供了一些工具来很好的解决，Cargo 并不想替代它们，但是为了给用户带来一些便利，Cargo 提供了自定义...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/cargo/reference/build-script/intro.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"构建脚本( Build Scripts)"}],["meta",{"property":"og:description","content":"构建脚本( Build Scripts) 一些项目希望编译第三方的非 Rust 代码，例如 C 依赖库；一些希望链接本地或者基于源码构建的 C 依赖库；还有一些项目需要功能性的工具，例如在构建之间执行一些代码生成的工作等。 对于这些目标，社区已经提供了一些工具来很好的解决，Cargo 并不想替代它们，但是为了给用户带来一些便利，Cargo 提供了自定义..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"构建脚本( Build Scripts)\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{},"readingTime":{"minutes":7.56,"words":2268},"filePathRelative":"cargo/reference/build-script/intro.md","excerpt":"\\n<p>一些项目希望编译第三方的非 Rust 代码，例如 C 依赖库；一些希望链接本地或者基于源码构建的 C 依赖库；还有一些项目需要功能性的工具，例如在构建之间执行一些代码生成的工作等。</p>\\n<p>对于这些目标，社区已经提供了一些工具来很好的解决，Cargo 并不想替代它们，但是为了给用户带来一些便利，Cargo 提供了自定义构建脚本的方式，来帮助用户更好的解决类似的问题。</p>\\n<h2>build.rs</h2>\\n<p>若要创建构建脚本，我们只需在项目的根目录下添加一个 <code>build.rs</code> 文件即可。这样一来， Cargo 就会先编译和执行该构建脚本，然后再去构建整个项目。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"SUMMARY.html"}],"localMap":{"nodes":[{"id":"cargo/reference/build-script/intro.md","value":{"title":"intro","path":"cargo/reference/build-script/intro.md","outlink":[],"backlink":["SUMMARY.md"]}},{"id":"SUMMARY.md","value":{"title":"SUMMARY","path":"SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"SUMMARY.md","target":"cargo/reference/build-script/intro.md"}]}}}');export{h as comp,d as data};
