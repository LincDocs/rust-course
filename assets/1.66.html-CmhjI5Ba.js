import{_ as i,e as a,f as n,o as e}from"./app-DFfX2bp8.js";const l={};function t(p,s){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="rust-新版解读-1-66-重点-有字段枚举的显示判别" tabindex="-1"><a class="header-anchor" href="#rust-新版解读-1-66-重点-有字段枚举的显示判别"><span>Rust 新版解读 | 1.66 | 重点: 有字段枚举的显示判别</span></a></h1><blockquote><p>Rust 1.66 官方 release doc: <a href="https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html" target="_blank" rel="noopener noreferrer">Announcing Rust 1.66.0 | Rust Blog</a></p></blockquote><p>通过 <a href="https://www.rust-lang.org/tools/install" target="_blank" rel="noopener noreferrer">rustup</a> 安装的同学可以使用以下命令升级到 1.66 版本:</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rustup</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> update</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> stable</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="对有字段枚举的显示判别" tabindex="-1"><a class="header-anchor" href="#对有字段枚举的显示判别"><span>对有字段枚举的显示判别</span></a></h2><p>枚举的显示判别在跨语言传递值时很关键，需要两个语言里每个枚举值的判别是一致的，比如：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">#[repr(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">u8</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">)]</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">enum</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Bar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">    A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">    B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">    C</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">    D</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子里，枚举 <code>Bar</code> 使用了 <code>u8</code> 作为原语表形(representation)，并且 <code>Bar::C</code> 使用 42 来判别，其它没有显示判别的枚举值会按照源码里地顺序自动地递增赋值，这里的 <code>Bar::A</code> 是0，<code>Bar::B</code> 是1，<code>Bar::D</code> 是43。如果没有显示判别，那就只能在 <code>Bar::B</code> 和 <code>Bar::C</code> 之间加上 40 个无意义的枚举值了。</p><p>在1.66之前，枚举的显示判别只能用在无字段枚举上。现在对有字段枚举的显示判别也稳定了：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">#[repr(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">u8</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">)]</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">enum</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">u8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">bool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：可以通过 <code>as</code> 转换（比如 <code>Bar::C as u8</code> ）来判断一个无字段枚举的判别值，但是 Rust 还没有给有字段枚举提供语言层面上的获取原始判别值的方法，只能通过 unsafe 的代码来检查有字段枚举的判别值。考虑到这个使用场景往往出现在必须使用 unsafe 代码的跨语言的 FFI 里，希望这没有造成太大的负担。如果你的确需要的话，参考 <code>std::mem::discriminant</code>。</p><h2 id="黑盒方法-core-hint-black-box" tabindex="-1"><a class="header-anchor" href="#黑盒方法-core-hint-black-box"><span>黑盒方法 <code>core::hint::black_box</code></span></a></h2><p>当对编译器产生的代码做基准测试时，常常需要阻止一些优化，比如下面的代码里， <code>push_cap</code> 在一个循环里执行了4次 <code>Vec::push</code> ：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> push_cap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> Vec</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">pub</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> bench_push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() -&gt; </span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;">Duration</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> v</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> Vec</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">with_capacity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> now</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> Instant</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">now</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    push_cap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    now</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">elapsed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你检查一下在 x86_64 机器上编译的优化输出结果，你会注意到整个 <code>push_cap</code> 方法都被优化掉了...</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>example::bench_push:</span></span>
<span class="line"><span>  sub rsp, 24</span></span>
<span class="line"><span>  call qword ptr [rip + std::time::Instant::now@GOTPCREL]</span></span>
<span class="line"><span>  lea rdi, [rsp + 8]</span></span>
<span class="line"><span>  mov qword ptr [rsp + 8], rax</span></span>
<span class="line"><span>  mov dword ptr [rsp + 16], edx</span></span>
<span class="line"><span>  call qword ptr [rip + std::time::Instant::elapsed@GOTPCREL]</span></span>
<span class="line"><span>  add rsp, 24</span></span>
<span class="line"><span>  ret</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在可以通过调用 <code>black_box</code> 来避免类似情况的发送。 虽然实际上 <code>black_box</code> 内部只会取走值并直接返回，但是编译器会认为这个方法可能做任何事情。</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">hint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::black_box;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> push_cap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> Vec</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">i32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">..</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        black_box</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">as_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就可以得到展开循环的<a href="https://rust.godbolt.org/z/Ws1GGbY6Y" target="_blank" rel="noopener noreferrer">结果</a>：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>  mov dword ptr [rbx], 0</span></span>
<span class="line"><span>  mov qword ptr [rsp + 8], rbx</span></span>
<span class="line"><span>  mov dword ptr [rbx + 4], 1</span></span>
<span class="line"><span>  mov qword ptr [rsp + 8], rbx</span></span>
<span class="line"><span>  mov dword ptr [rbx + 8], 2</span></span>
<span class="line"><span>  mov qword ptr [rsp + 8], rbx</span></span>
<span class="line"><span>  mov dword ptr [rbx + 12], 3</span></span>
<span class="line"><span>  mov qword ptr [rsp + 8], rbx</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你还能发现结果里有 <code>black_box</code> 带来的副作用，无意义的 <code>mov qword ptr [rsp + 8], rbx</code> 指令在每一次循环后出现，用来获取 <code>v.as_ptr()</code> 作为参数传递给并未真正使用的方法。</p><p>注意到上面的例子里，<code>push</code> 指令都不用考虑内存分配的问题，这是因为编译器运行在 <code>Vec::with_capacity(4)</code> 的条件下。你可以尝试改动一下 <code>black_box</code> 的位置或者在多处使用，来看看其对编译的优化输出的影响。</p><h2 id="cargo-remove" tabindex="-1"><a class="header-anchor" href="#cargo-remove"><span><code>cargo remove</code></span></a></h2><p>1.62里我们引入了 <code>cargo add</code> 来通过命令行给你的项目增加依赖项。现在可以使用 <code>cargo remove</code> 来移除依赖了。</p><h2 id="others" tabindex="-1"><a class="header-anchor" href="#others"><span>Others</span></a></h2><p>其它更新细节，和稳定的API列表，参考<a href="https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html#stabilized-apis" target="_blank" rel="noopener noreferrer">原Blog</a></p>`,26)]))}const r=i(l,[["render",t],["__file","1.66.html.vue"]]),k=JSON.parse('{"path":"/src/appendix/rust-versions/1.66.html","title":"Rust 新版解读 | 1.66 | 重点: 有字段枚举的显示判别","lang":"zh-CN","frontmatter":{"description":"Rust 新版解读 | 1.66 | 重点: 有字段枚举的显示判别 Rust 1.66 官方 release doc: Announcing Rust 1.66.0 | Rust Blog 通过 rustup 安装的同学可以使用以下命令升级到 1.66 版本: 对有字段枚举的显示判别 枚举的显示判别在跨语言传递值时很关键，需要两个语言里每个枚举值的判别...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/src/appendix/rust-versions/1.66.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"Rust 新版解读 | 1.66 | 重点: 有字段枚举的显示判别"}],["meta",{"property":"og:description","content":"Rust 新版解读 | 1.66 | 重点: 有字段枚举的显示判别 Rust 1.66 官方 release doc: Announcing Rust 1.66.0 | Rust Blog 通过 rustup 安装的同学可以使用以下命令升级到 1.66 版本: 对有字段枚举的显示判别 枚举的显示判别在跨语言传递值时很关键，需要两个语言里每个枚举值的判别..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-24T15:57:50.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-24T15:57:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Rust 新版解读 | 1.66 | 重点: 有字段枚举的显示判别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-24T15:57:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{"createdTime":1745510270000,"updatedTime":1745510270000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":3.04,"words":913},"filePathRelative":"src/appendix/rust-versions/1.66.md","localizedDate":"2025年4月24日","excerpt":"\\n<blockquote>\\n<p>Rust 1.66 官方 release doc: <a href=\\"https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Announcing Rust 1.66.0 | Rust Blog</a></p>\\n</blockquote>\\n<p>通过 <a href=\\"https://www.rust-lang.org/tools/install\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">rustup</a> 安装的同学可以使用以下命令升级到 1.66 版本:</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"src/SUMMARY.html"}],"localMap":{"nodes":[{"id":"src/appendix/rust-versions/1.66.md","value":{"title":"1.66","path":"src/appendix/rust-versions/1.66.md","outlink":[],"backlink":["src/SUMMARY.md"]}},{"id":"src/SUMMARY.md","value":{"title":"SUMMARY","path":"src/SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"src/SUMMARY.md","target":"src/appendix/rust-versions/1.66.md"}]}}}');export{r as comp,k as data};
