import{_ as i,e as a,f as n,o as e}from"./app-C_xW6TWK.js";const t={};function l(p,s){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="复合类型" tabindex="-1"><a class="header-anchor" href="#复合类型"><span>复合类型</span></a></h1><p>行百里者半九十，欢迎大家来到这里，虽然还不到中点，但是已经不远了。如果说之前学的基础数据类型是原子，那么本章将讲的数据类型可以认为是分子。</p><p>本章的重点在复合类型上，顾名思义，复合类型是由其它类型组合而成的，最典型的就是结构体 <code>struct</code> 和枚举 <code>enum</code>。例如平面上的一个点 <code>point(x, y)</code>，它由两个数值类型的值 <code>x</code> 和 <code>y</code> 组合而来。我们无法单独去维护这两个数值，因为单独一个 <code>x</code> 或者 <code>y</code> 是含义不完整的，无法标识平面上的一个点，应该把它们看作一个整体去理解和处理。</p><p>来看一段代码，它使用我们之前学过的内容来构建文件操作：</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" data-title="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">#![allow(unused_variables)]</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> File</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> open</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> File</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">bool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    true</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> File</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">bool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    true</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">#[allow(dead_code)]</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> File</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">save_to</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: &amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> Vec</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">u8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;) -&gt; </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    unimplemented!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> f1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> File</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;f1.txt&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    open</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> f1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //read(&amp;mut f1, &amp;mut vec![]);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mut</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> f1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们的学习非常类似原型设计：有的方法只提供 API 接口，但是不提供具体实现。此外，有的变量在声明之后并未使用，因此在这个阶段我们需要排除一些编译器噪音（Rust 在编译的时候会扫描代码，变量声明后未使用会以 <code>warning</code> 警告的形式进行提示），引入 <code>#![allow(unused_variables)]</code> 属性标记，该标记会告诉编译器忽略未使用的变量，不要抛出 <code>warning</code> 警告，具体的常见编译器属性你可以在这里查阅：<a href="https://course.rs/profiling/compiler/attributes.html" target="_blank" rel="noopener noreferrer">编译器属性标记</a>。</p><p><code>read</code> 函数也非常有趣，它返回一个 <code>!</code> 类型，这个表明该函数是一个发散函数，不会返回任何值，包括 <code>()</code>。<code>unimplemented!()</code> 告诉编译器该函数尚未实现，<code>unimplemented!()</code> 标记通常意味着我们期望快速完成主要代码，回头再通过搜索这些标记来完成次要代码，类似的标记还有 <code>todo!()</code>，当代码执行到这种未实现的地方时，程序会直接报错。你可以反注释 <code>read(&amp;mut f1, &amp;mut vec![]);</code> 这行，然后再观察下结果。</p><p>同时，从代码设计角度来看，关于文件操作的类型和函数应该组织在一起，散落得到处都是，是难以管理和使用的。而且通过 <code>open(&amp;mut f1)</code> 进行调用，也远没有使用 <code>f1.open()</code> 来调用好，这就体现出了只使用基本类型的局限性：<strong>无法从更高的抽象层次去简化代码</strong>。</p><p>接下来，我们将引入一个高级数据结构 —— 结构体 <code>struct</code>，来看看复合类型是怎样更好的解决这类问题。 开始之前，先来看看 Rust 的重点也是难点：字符串 <code>String</code> 和 <code>&amp;str</code>。</p>`,9)]))}const k=i(t,[["render",l],["__file","intro.html.vue"]]),d=JSON.parse('{"path":"/src/basic/compound-type/intro.html","title":"复合类型","lang":"zh-CN","frontmatter":{"description":"复合类型 行百里者半九十，欢迎大家来到这里，虽然还不到中点，但是已经不远了。如果说之前学的基础数据类型是原子，那么本章将讲的数据类型可以认为是分子。 本章的重点在复合类型上，顾名思义，复合类型是由其它类型组合而成的，最典型的就是结构体 struct 和枚举 enum。例如平面上的一个点 point(x, y)，它由两个数值类型的值 x 和 y 组合而来...","head":[["meta",{"property":"og:url","content":"https://LincDocs.github.io/rust-course/src/basic/compound-type/intro.html"}],["meta",{"property":"og:site_name","content":"rust-course"}],["meta",{"property":"og:title","content":"复合类型"}],["meta",{"property":"og:description","content":"复合类型 行百里者半九十，欢迎大家来到这里，虽然还不到中点，但是已经不远了。如果说之前学的基础数据类型是原子，那么本章将讲的数据类型可以认为是分子。 本章的重点在复合类型上，顾名思义，复合类型是由其它类型组合而成的，最典型的就是结构体 struct 和枚举 enum。例如平面上的一个点 point(x, y)，它由两个数值类型的值 x 和 y 组合而来..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://course.rs/profiling/compiler/attributes.html"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-20T14:07:43.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-20T14:07:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"复合类型\\",\\"image\\":[\\"https://course.rs/profiling/compiler/attributes.html\\"],\\"dateModified\\":\\"2025-04-20T14:07:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LincDocs\\",\\"url\\":\\"https://github.com/LincDocs/rust-course/\\"}]}"]]},"git":{"createdTime":1745158063000,"updatedTime":1745158063000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":2.46,"words":737},"filePathRelative":"src/basic/compound-type/intro.md","localizedDate":"2025年4月20日","excerpt":"\\n<p>行百里者半九十，欢迎大家来到这里，虽然还不到中点，但是已经不远了。如果说之前学的基础数据类型是原子，那么本章将讲的数据类型可以认为是分子。</p>\\n<p>本章的重点在复合类型上，顾名思义，复合类型是由其它类型组合而成的，最典型的就是结构体 <code>struct</code> 和枚举 <code>enum</code>。例如平面上的一个点 <code>point(x, y)</code>，它由两个数值类型的值 <code>x</code> 和 <code>y</code> 组合而来。我们无法单独去维护这两个数值，因为单独一个 <code>x</code> 或者 <code>y</code> 是含义不完整的，无法标识平面上的一个点，应该把它们看作一个整体去理解和处理。</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"SUMMARY","link":"src/SUMMARY.html"}],"localMap":{"nodes":[{"id":"src/basic/compound-type/intro.md","value":{"title":"intro","path":"src/basic/compound-type/intro.md","outlink":[],"backlink":["src/SUMMARY.md"]}},{"id":"src/SUMMARY.md","value":{"title":"SUMMARY","path":"src/SUMMARY.md","outlink":[],"backlink":[]}}],"links":[{"source":"src/SUMMARY.md","target":"src/basic/compound-type/intro.md"}]}}}');export{k as comp,d as data};
